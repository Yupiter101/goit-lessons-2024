<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
    <link rel="stylesheet" href="../../css/style-js-btn-top.css">
    <link rel="stylesheet" href="../../css/style-video.css">
</head>

<body>
    <header>
        <div>
            <a class="fixed-back" href="../../index.html">Home</a>
        </div>
    </header>

    <main>
        <!-- Button to top -->
        <button class="toTop">
            <svg class="svgButtonToTop" xmlns="http://www.w3.org/2000/svg" width="32" height="32">
                <path d="M16 1 1 16h9v16h12V16h9z" />
            </svg>
        </button>

        <section class="section-title">
            <div class="container">
                <h1>Server</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>http - з коробки</li>
                    <li>express - конспект</li>
                    <li>express - лекція. Закінчив на 0:35:00</li>
                    <li>middleware - Проміжне ПЗ</li>
                    <li>Способи передачі даних на сервер</li>
                    <li>Роутінг у додатку. Методи</li>
                    <li>??? Приклад програм</li>
                    <li>Змінні оточення</li>
                    <li>Логування</li>
                    <li>Що таке REST</li>
                    <li>Основні методи HTTP</li>
                    <li>CORS</li>
                    <li>Формування URL для REST API</li>
                    <li>Приклад REST API програми</li>
                </ol>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>http - з коробки. Практика</h2>
                <p>Матеріал взято з 
                    <a href="https://www.youtube.com/watch?v=26SZU_Q2gs0&t=1523s&ab_channel=GoIT">
                        відео уроку
                    </a> Less-3/1
                </p>
                <p><b>Хост</b> - <code>http://localhost:8080</code>, де localhost - hostname  8080 - port</p>
                <p>Port бажано починати більше ніж 1500</p>
                <p>Приклад перевіреного коду:</p>
                <pre>
    console.log("Сервер з коробки http-serv.js");
    const http = require("node:http");

    const server = http.createServer((request, response) => {
        const {url, method} = request;

        if(method === "GET" && url === "/") {
            return response.end("Hello http!");
        }

        if(method === "GET" && url === "/movies") {
            return response.end("Hello movies!");
        }
        response.statusCode = 404;
        response.end("Not found");
    });


    // http://localhost:8080
    server.listen(8080, ()=> {
        console.log("Server runing 8080 port");
    });
                    </pre>
                
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>express</h2>
                <p>
                    Express – це мінімалістичний та гнучкий вебфреймворк для застосунків Node.js
                    Давайте відразу приступимо до практики
                </p>
                <ol>
                    <li>Create project: <code>$ mkdir myapp; $ cd myapp</code> </li>
                    <li><code>$ npm init -y</code></li>
                    <li><code>$ touch .gitignore</code></li>
                    <li><code>$ npm install express</code></li>
                    <li>створіть файл з ім'ям app.js та додайте наступний код:</li>
                </ol>
                <pre>
    const express = require('express');
    const app = express();
                    
    app.get('/', (req, res) => {
     res.send('Hello World!');
    });
                    
    app.listen(3000, () => {
     console.log('Example app listening on port 3000!');
    });
                </pre>
                <p><code>$ node app.js</code></p>

                <p>
                    Заходимо у браузер, вводимо адрему <code>http://localhost:3000</code>
                    Застосунок видає відповідь “Hello World!” у браузері на запити, адресовані кореневому URL (/) або маршруту. 
                    Для всіх інших шляхів відповіддю буде статус 404 - Not Found.
                </p>
                <p>
                    Маршрутизація визначає, як ваш застосунок відповідає на клієнтський запит до конкретної 
                    адреси – URL. Кожен маршрут може мати одну або більше функцій обробки, що виконуються 
                    при зіставленні маршруту. Визначення маршруту, відповідно до документації, має наступну 
                    структуру:
                </p>
                <pre>app.METHOD(PATH, HANDLER)</pre>
                <ul>
                    <li>app — це екземпляр express застосунку</li>
                    <li><b>METHOD</b> — метод запиту HTTP (GET, POST, PUT, PATCH, DELETE).</li>
                    <li><b>PATH</b> — шлях на сервері, у нашому випадку – це корінь сайту '/'.</li>
                    <li><b>HANDLER</b> — функція, що виконується при зіставленні маршруту.</li>
                    <li><b>req</b> - об'єкт запиту</li>
                    <li><b>res</b> - об'єкт відповіді</li>
                </ul>
                <p>Додамо обробник маршруту contact</p>
                <pre>
    app.get('/contact', (req, res) => {
        res.send('Contact page');
    });
                </pre>
                <p>
                    І тепер за шляхом http://localhost:3000/contact сервер нам буде повертати сторінку із заголовком Contact page.
                </p>
                <p>
                    Але визначення маршрутів, крім простих рядків, можуть також містити регулярні вирази або спеціальні 
                    символи підстановок. Зокрема, ми можемо використовувати такі символи, як ?, +, * и ().
                </p>
                <ul>
                    <li>
                        <b>'/con?tact'</b> - Символ ? у маршруті вказує, що попередній символ може зустрічатися 1 раз 
                        або бути відсутнім
                    </li>
                    <li>
                        Символ + вказує, що попередній символ може зустрічатися 1 і більше разів. Цей шлях маршруту 
                        зіставляє contact, conntact, connntact тощо.
                    </li>
                    <li>
                        Символ зірочка * вказує, що на місці цього символу може бути будь-яка кількість символів. 
                        Цей шлях маршруту зіставляє contact, conxtact, con123tact тощо.
                    </li>
                    <li></li>
                </ul>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>express. Практика</h2>
                <p>Матеріал взято з 
                    <a href="https://www.youtube.com/watch?v=26SZU_Q2gs0&t=1523s&ab_channel=GoIT">
                        відео уроку
                    </a> Less-3/1
                </p>
                <p><a href="https://expressjs.com/" target="_blank">expressjs.com</a></p>
                <p><code>$ npm install express --save</code></p>
                
                <pre>
    const express = require('express')
    const app = express()
    const port = 3000

    app.get('/', (req, res) => {
        res.send('Hello World!')
    })

    app.listen(port, () => {
        console.log(`Example app listening on port ${port}`)
    })
                </pre>
                <p>Опис цікавого:</p>
                <ul>
                    <li>http://localhost:3000/?api-key=123  -  так можна задавати квері парамнтри</li>
                    <li>const apiKey = req.query["apikey"];</li>
                    <li>const apiKey = req.query.apikey;</li>
                    <li>Нормально працює тільки через постман</li>
                    <li>Middlevare app.use((req, res, next)=> {}) - міделвара для усіх запитів</li>
                    <li>Middlevare app.use("/books", (req, res, next)=> {}) - міделвара для "/books"</li>
                 
                </ul>

                <h2>CORS</h2>

                <p>
                    прибирає конфлікт між різними серверами і браузером
                </p>
                <ul>
                    <li>npm i cors</li>
                    <li>const cors = require("cors");</li>
                    <li>app.use(cors());</li>
                    <li></li>
                </ul>

            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>middleware - Проміжне ПЗ</h2>
                <p>
                    проміжне ПЗ – просто функція, що приймає три аргументи: об'єкт запиту (req), об'єкт відповіді (res) і функцію next.
                    Вбудуємо власне проміжне ПЗ у наш файл app.js
                </p>
                <pre>
   app.use((req, res, next) => {
       console.log('Наше проміжне ПЗ');
       next();
   });
                </pre>
                <p>
                    Ця функція нічого не виконує, просто пропускає потік через себе, але в консоль завжди буде 
                    вискакувати наше повідомлення.
                </p>
                <p>
                    Функції проміжної обробки (middleware) – це функції, що мають доступ до об'єкту запиту (req), 
                    об'єкту відповіді (res) і до наступної функції проміжної обробки в циклі "запит-відповідь" 
                    застосунку. Наступна функція проміжної обробки, як правило, позначається змінною next.
                    Функції проміжної обробки виконують наступні завдання:
                </p>
                <ul>
                    <li>виконують певний код.</li>
                    <li>вносять зміни до об'єктів запитів та відповідей.</li>
                    <li>можуть завершити цикл "запит-відповідь" та перервати обробку запиту.</li>
                    <li>викликають наступну функцію проміжної обробки зі стеку, виконанням функції next().</li>
                </ul>

            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Передача даних на сервер</h2>
                <h3>Передача параметра в URL</h3>
                <p>
                    Маршрути можуть містити параметри — іменовані сегменти URL- адреси. 
                    Назва параметра повинна містити символи з діапазону [A-Za-z0-9_]. 
                    У визначенні маршруту перед параметром ставиться знак двокрапки.
                </p>
                <pre>
    app.get('/contact/:id', (req, res) => {
        const id = req.params.id;
        res.send(`&lt;h1&gt;Contact&lt;/h1&gt; Параметр: ${req.params.id}`);
    });
                </pre>
                <p>
                    Якщо ми тепер звернемося за маршрутом /contact/123, то req.params.id міститиме значення 123.
                </p>
                <h3>Використання параметрів GET запиту</h3>
                <p>
                    Другий спосіб – це розбір рядка GET запиту. Після URL-адреси, за якою відбувається звернення на сервер, 
                    ставиться знак питання ?, за яким слідує список аргументів, розділених символами &. Щось на кшталт
                </p>
                <pre>http://localhost:3000/contacts?skip=0&limit=10</pre>
                <p>
                    Без цього способу не обходиться жодна реалізація пагінації на сторінці. Результат такого запиту 
                    знаходиться в об'єкті req.query.
                </p>
                <pre>
    {
        skip: 0,
        limit: 10
    }
                </pre>
                <p>
                    Яущо у GET запиті HTTP параметри рядка запиту не задані, наприклад /search, а знака питання і після нього 
                    нічого немає, то req.query за замовчуванням містить порожній об'єкт: {}
                </p>
                <p>
                    Фреймворк Express, містить вбудований засіб розбору рядків запитів, тому що це завдання дуже 
                    часто зустрічається у веб-розробці.
                </p>

                <h3>Надсилання за допомогою форм</h3>
                <p>
                    Під час надсилання якихось даних на сервер зазвичай використовуються HTTP методи POST, PUT та PATCH. 
                    Це стандартний спосіб під час надсилання форми. Розглянемо, як отримувати такі дані в Express.
                </p>
                <p>
                    Формат HTTP повідомлення складається зі списку заголовків та тіла повідомлення. 
                    Запит POST від форми стандартно має заголовок Content-Type: application/x-www-form-urlencoded. 
                    Насамперед для отримання відправлених даних необхідно підключити парсер через проміжне ПЗ і 
                    він уже міститься у фреймворку. Для створення парсера даних від форм застосовується функція urlencoded().:
                </p>
                <pre>app.use(express.urlencoded({ extended: false }));</pre>
                <p>
                    В цю функцію передається об'єкт, який визначає параметри парсингу. Значення extended: 
                    false вказує, що результат парсингу буде представляти набір пар ключ-значення, а кожне 
                    значення може бути представлене у вигляді рядка або масиву. Коли цей параметр дорівнює 
                    true, парсер використовує іншу бібліотеку для розбору формату рядка.
                </p>
                <p>
                    В цю функцію передається об'єкт, який визначає параметри парсингу. Значення extended: false вказує, 
                    що результат парсингу буде представляти набір пар ключ-значення, а кожне значення може бути 
                    представлене у вигляді рядка або масиву. Коли цей параметр дорівнює true, парсер використовує 
                    іншу бібліотеку для розбору формату рядка.
                </p>
                <pre>
    &ltform action="/login" method="POST"&gt;
        &lt;label for="email"&gt;Email&lt;/label&gt;
        &lt;input type="text" name="email" id="email" /&gt;
        &lt;label for="password"&gt;Пароль&lt;/label&gt;
        &lt;input type="password" name="password" id="password" /&gt;
        &lt;button type="submit"&gt;Увійти&lt;/button&gt;
    &lt;/form&gt;
                </pre>
                <p>
                    Браузер відправить на URL <урл нашого застосунку>/login дані форми. Це будуть 
                    дві змінні: email та password. За це відповідають атрибути name у відповідних 
                    тегів input. 
                </p>
                <p>
                    Ці дані ми повинні прийняти на стороні сервера наступним обробником
                </p>
                <pre>
    app.post('/login', (req, res, next) => {
        const { email, password } = req.body;
        // Виконуємо необхідні операції
    });
                </pre>
                <p>
                    В результаті сервер повинен отримати дані в об'єкті req.body наступного виду:
                </p>
                <pre>
    {
        email: 'Значення, що було введено в поле input',
        password: 'Значення, що було введено в поле input'
    }
                </pre>

                <h3>Передача JSON</h3>
                <p>
                    При створенні вебзастосунків на Node.js часто доводиться працювати з даними в JSON форматі. 
                    Це основна форма передачі даних для Web-API, ще є формат XML, але він все більше застаріває 
                    через свою багатослівність при формуванні даних і виходить із обігу.
                </p>
                <p>
                    Парсер JSON у застосунку підключається наступним чином.
                </p>
                <pre>app.use(express.json());</pre>
                <p>
                    Передати дані у вигляді JSON можна клієнтським JavaScript за допомогою спеціальної утиліти типу Postman
                </p>
                <pre>
    app.post('/login', (req, res, next) => {
        const { email, password } = req.body;
        // Виконуємо необхідні операції
    });
                </pre>
                <p>
                    Цей приклад припускає, що надіслано об'єкт JSON з властивостями email та password. 
                    І головне у запиту заголовок Content-Type повинен зберігати application/json, 
                    а ви повинні надіслати дійсну розмітку JSON.
                </p>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Роутінг у додатку</h2>
                <h3>Методи Route</h3>
                <p>
                    За допомогою класу express.Router можна створювати модульні, монтовані обробники маршрутів. 
                    <code>Екземпляр Router</code> є комплексною системою проміжних обробників та маршрутизації; 
                    тому його часто називають «мінізастосунком»
                </p>

                <pre>
    const express = require('express');
    const router = express.Router();
    // визначимо домашній роутер
    router.get('/', (req, res) =&gt; {
    res.send('Це головний роутер');
    });
    // визначимо роутер about
    router.get('/about', (req, res) =&gt; {
    res.send('About');
    });
    module.exports = router;
                </pre>
                <p>Потім підключимо модуль my-router.js маршрутизації у застосунок:</p>
                <pre>
    const myRouter= require('./my-router');
        ...
    app.use('/my-router', myRouter);
                </pre>
                <p>
                    Цей застосунок тепер зможе обробляти запити, адресовані ресурсам /my-router та /my-router/about.
                </p>
                <p>
                    Існує також особливий метод маршрутизації, app.all(), що не є похідним від будь-якого методу HTTP. 
                    Цей метод використовується для завантаження функцій проміжної обробки на шляху для всіх методів запитів. 
                    Він буває корисний, коли нам потрібно реагувати на будь-яке звернення до сервера.
                </p>
                <pre>
    app.all('/anything', (req, res, next) => {
        console.log('Anything method.');
        next(); // передаємо управління далі
    });
                </pre>
                <p>
                    У наведеному нижче прикладі обробник буде запущений для запитів, адресованих /anything, незалежно 
                    від того, чи використовується GET, POST, PUT, DELETE або будь-який інший метод запиту HTTP, 
                    що підтримується в модулі http.
                </p>

                <h3>Методи відповіді</h3>
                <p>
                    Методи в об'єкті відповіді (res), перелічені в таблиці нижче, можуть передавати відповідь клієнту 
                    та завершувати цикл “запит-відповідь”. Якщо жоден із цих методів не буде викликано з обробника 
                    маршруту, клієнтський запит зависне.
                </p>
                <div>
                    <img src="https://s3.eu-north-1.amazonaws.com/lms.goit.files/a782c93c-df9a-417a-97c0-d5ccfafa81b8image.png" alt="qew">
                </div>

                <h3>Ланцюжки методів</h3>
                <p>
                    Метод <code>app.route()</code> дозволяє створювати обробники маршрутів, що утворюють ланцюжки для конкретного шляху 
                    маршруту. Оскільки шлях один і той самий для різних методів HTTP, зручно створювати модульні маршрути, 
                    щоб мінімізувати надмірність та кількість друкарських помилок. Нижче наведено приклад об'єднаних у 
                    ланцюжок обробників маршрутів, визначених за допомогою функції <code>app.route()</code>.
                </p>
                <pre>
    app
    .route('/blog')
    .get((req, res) => {
    res.send('Get a list of blog');
    })
    .post((req, res) => {
    res.send('Add a record to blog');
    })
    .put((req, res) => {
    res.send('Update blog');
    });
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2></h2>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Змінні оточення</h2>
                <p>
                    Код доступний усім, хто його бачить, а, значить, і наші секретні ключі також.
                    Як вирішують цю проблему? Правильне рішення – використовувати змінні середовища. 
                    Це локальні змінні, які доступні нашому застосунку. Створення цих змінних виконується 
                    за допомогою модуля dotenv.
                </p>
                <p>
                    Цей модуль завантажує змінні середовища з файлу .env, який ви створюєте, наприклад, 
                    у кореневому каталозі нашого застосунку. Потім ми підключаємо модуль у нашому застосунку 
                    і він додає змінні оточення в об'єкт process.env, і вже звідти, не показуючи значення 
                    цих змінних, ми можемо використовувати їх у застосунку. Само собою файл .env ми повинні 
                    додати до файлу .gitignore
                </p>
                <p>
                    <code>npm install dotenv</code>
                    <a href="https://www.npmjs.com/package/dotenv" target="_blank">Дивись приклад</a>
                </p>
                <ol>
                    <li><code>npm install dotenv</code></li>
                    <li><code>require('dotenv').config();</code> додамо у файл</li>
                    <li>Потім створюємо  файл <code>.env</code> у кореневому каталозі нашого застосункута додаємо в нього змінні.</li>
                    <li><code>SECRET_KEY=123456</code></li>
                    <li><code>NODE_ENV=development</code></li>
                </ol>
                <p>
                    Тепер у файлі застосунку app.js будуть доступні будь-які змінні, які ми додали до файлу .env. 
                    Ці змінні доступні тепер у застосунку наступним чином
                </p>
                <pre>
    process.env.SECRET_KEY;
    rocess.env.NODE_ENV;
                </pre>
                <p>
                    Надалі ми завжди використовуватимемо змінні оточення для доступу до секретних даних, таких як секретні слова 
                    для cookie або jwt, url підключення до бази даних та інше.
                </p>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Логування</h2>
                <p>
                    В будь-якому застосунку необхідне протоколювання запитів на сервер.
                    Генератор застосунків використовує для цього модуль <code>morgan</code> — гнучкий 
                    проміжний компонент для протоколювання запитів з можливістю налаштування 
                    формату виведення.
                </p>
                <ol>
                    <li><code>npm i morgan</code></li>
                    <li><code>const morgan = require('morgan');</code></li>
                    <li>...</li>
                    <li>app.use(logger('dev'))</li>
                </ol>
                <p>
                    Для розробки ми використовуємо певний формат журналу dev. Є п'ять наперед визначених форматів, 
                    які ми можемо використовувати, щоб легко отримати необхідну інформацію:
                </p>
                <ol>
                    <li>
                        <code>combined</code> – використовує режим combined серверу Apache для формату журналів
                        <code>:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status 
                            :res[content-length] ":referrer" ":user-agent"
                        </code>
                    </li>
                    <li>
                        <code>common</code>
                         – використовує режим common серверу Apache для формату журналів
                         <code>
                            :remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length]
                         </code>
                    </li>
                    <li>
                        <code>dev</code> – формат журналу з колірним кодуванням (за статусом запиту). Маркер буде пофарбований 
                        у зелений колір для кодів успіху, червоний – для кодів помилок сервера, жовтий – для 
                        кодів помилок клієнта, бірюзовий – для перенаправлення кодів та незабарвлених 
                        інформаційних кодів
                        <code>
                            :method :url :status :response-time ms - :res[content-length]
                        </code>
                    </li>
                    <li>
                        <code>short</code> коротше, ніж формат за замовчуванням
                        <code>:remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms</code>
                    </li>
                    <li>
                        <code>tiny</code>
                         – найкоротше виведення, лише час відповіді та кілька додаткових елементів.
                         <code>:method :url :status :res[content-length] - :response-time ms</code>
                    </li>
                    <p>
                        Корисність логера полягає в тому, що він дозволить вам обробити свої журнали аналітичними 
                        застосунками, що генерують корисну статистику. При видачі запитів від різних клієнтських 
                        застосунків у журналі буде видно рядок, що ідентифікує агента. Можна створювати власні 
                        формати журналу. Для цього потрібно передати спеціальний рядок маркерів. Наприклад, 
                        наступний формат :method :url :response-time ms буде створювати записи виду
                    </p>
                    <pre>GET / 15 ms:</pre>
                    <p>
                        За замовчуванням доступні наступні маркери. Ви також можете визначати нестандартні маркери та перенаправити виведення у файл журналу.
                    </p>
                </ol>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>REST</h2>
                <h2>Що таке URI та URL?</h2>
                <p>
                    Перш ніж ми перейдемо до того, які архітектурні обмеження накладає REST, давайте розберемося з термінологією URL та URI. 
                    Терміни URI та URL часто використовуються як синоніми, але це не зовсім одне й те саме.
                </p>
                <p>
                    URI
Є ідентифікатором конкретного ресурсу. Як сторінку, книгу або документ.
                </p>
                <p>
                    URL
Представляє особливий тип ідентифікатора, який також говорить вам, як отримати до нього доступ
                </p>
                <p>
                    В принципі URI – це ширше поняття і містить URL. Якщо проводити якісь аналогії спрощення, 
                    то можна вважати, що URI – це щось на зразок імені, а URL – конкретно ім'я і як до нього 
                    дістатися. Наприклад, ISBN книги – це URI, а ось https://goit.ua – це URL тут є ім'я і 
                    як до нього дійти – протокол. Тобто, якщо протокол (https, ftp тощо) або присутній, 
                    або мається на увазі для домену, ви повинні називати його URL-адресою, навіть якщо 
                    це також URI.
                </p>
                <p>Існує наступна традиційна форма запису `URL:</p>
                <pre>
scheme://[login[:password]@]host[:port]][/path][?query][#fragment];
http://user:password@host.com:80/resourse/path/?query=name&ttt=123#hash
                </pre>
                <ul>
                    <li>scheme – це мережевий протокол, за яким відбувається звернення до ресурсу</li>
                    <li>login – не обов'язковий параметр ім'я користувача, яке використовується для доступу до ресурсу</li>
                    <li>password – пароль вказаного користувача, якщо він необхідний</li>
                    <li>
                        host – повністю прописане доменне ім'я хоста в системі DNS (goit.ua) або IP-адреса хоста 
                        у формі чотирьох груп десяткових чисел, розділених крапками
                    </li>
                    <li>
                        port – порт хоста для підключення, згадайте ми часто використовували http://localhost:3000, 
                        де 3000 – це і є порт. Виникає закономірне питання, чому порт не вказується наприклад для URL у браузері. 
                        Просто браузер знає, що для протоколу http порт дорівнює 80, а для https він дорівнює 443 і підставляє його за нас
                    </li>
                    <li>path – уточнююча інформація про місцезнаходження ресурсу.</li>
                    <li>
                        query – рядок запиту з переданими на сервер (методом GET) параметрами. Починається із символу ?, 
                        роздільник параметрів – знак &. Приклад: ?foo=123&baz=234&bar=value
                    </li>
                    <li>
                        fragment – ідентифікатор із попереднім символом #. Часто його називають хеш – hash або якір. 
                        Якорем може бути вказаний заголовок всередині документа або атрибут id елемента. За таким посиланням 
                        браузер відкриє сторінку та перемістить вікно перегляду вказаного елемента. 
                        Наприклад, посилання на секцію контактів у лендінгу: https://example.com/#contact.
                    </li>
                </ul>

                <h3>Єдиний інтерфейс</h3>
                <p>
                    Це обмеження гарантує, що існує спільна мова між серверами та клієнтами, яка дозволяє 
                    замінювати або змінювати кожну частину без порушення роботи всієї системи. 
                    Це досягається за рахунок 4 додаткових обмежень:
                </p>
                <ul>
                    <li>ідентифікація ресурсів</li>
                    <li>маніпулювання ресурсами за допомогою уявлень</li>
                    <li>інформативні (самоописові) повідомлення</li>
                    <li>гіпермедіа.</li>
                </ul>
                <p>
                    1. Інтернет використовує URL для ідентифікації ресурсів та HTTP в якості стандарту зв'язку. 
                    Щоб отримати ресурс, який зберігається на сервері, клієнт відправляє HTTP-запит GET на URL, 
                    який ідентифікує цей ресурс. Щоразу, коли ви вводите адресу у свій браузер, ваш браузер 
                    робить запит GET на цей URL. Якщо він отримує статус 200 та HTML-документ, він відображає 
                    сторінку у вікні, щоб ви могли її переглянути.
                </p>
                <p>
                    2. Найпростіший приклад – це блог у мережі. Коли користувач створює нове повідомлення у блозі, 
                    комп'ютер-клієнт повідомляє серверу, що необхідно додати нове повідомлення у блог. 
                    Для цього він відправляє HTTP-запит POST, можливо PUT з контентом для нового повідомлення у блозі. 
                    Сервер надсилає відповідь клієнту, яка вказує, чи було створено повідомлення або виникла 
                    проблема створення запису.
                </p>
                <p>
                    3. Коли користувач вводить http://www.example.com в адресному рядку свого веб-браузера, 
                    браузер надсилає наступний HTTP-запит:
                    <pre>
    GET / HTTP/1.1
    Host: www.example.com
                    </pre>

                </p>

                <h3>Кешування</h3>
                <p>
                    Кешування належить до обмеження, при якому відповіді сервера повинні бути позначені як 
                    кешовані або некешовані. Кешування відбувається, коли клієнт зберігає попередні відповіді, 
                    отримані від сервера, тому, коли ці дані знову знадобляться, він може не робити запит через мережу, 
                    а використовувати кешовані дані. Кешування частково або повністю усуває деякі клієнт-серверні взаємодії, 
                    сприяючи масштабованості та продуктивності застосунку.
                </p>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Основні методи HTTP</h2>
                <p>Основні HTTP-методи GET/POST/PUT/DELETE</p>
                <ul>
                    
                    <li>Інформаційні 100 - 199</li>
                    <li>Успішні 200 - 299</li>
                    <li>200 (OK) - вірний запит</li>
                    <li>201 Create - створено успішно</li>
                    <li>204 - No Content усе вірно але нема чого передати</li>
                    <li>Перенаправлення 300 - 399</li>
                    <li>301: Moved Permanently</li>
                    <li>307: Temporary Redirect</li>
                    <li>Клієнтські помилки 400 - 499</li>
                    <li>400: Bad Request</li>
                    <li>401: Unauthorized</li>
                    <li>403: Forbidden - нема прав доступу</li>
                    <li>404: Not Found</li>
                    <li>Серверні помилки 500 - 599</li>
                    <li>500: Internal Server Error</li>
                    <li>501: Not Implemented</li>
                    <li>502: Bad Gateway</li>
                    <li>503: Service Unavailable</li>
                    <li>504: Gateway Timeout</li>
                </ul>
                <p>
                    Детальніше почитайте у стандарті RFC 2616 або простіше 
                    <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Status" target="_blank">MDN</a> 
                </p>
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>CORS</h2>
                <p>
                    Cross-Origin Resource Sharing (CORS, перехресний обмін ресурсами) – це механізм, який за 
                    допомогою HTTP-заголовків дає браузеру дозвіл завантажувати ресурси з певного джерела 
                    на запит вебзастосунку, отриманого з іншого джерела.
                </p>
                <p>
                    З метою безпеки всі браузери припиняють усі перехресні HTTP-запити, які здійснюються клієнтським 
                    JavaScript. Це називається дотримання правила одного джерела і виходить, що вебзастосунок, 
                    отриманий з певного домену (Github pages), не може виконувати запити до HTTP-ресурсів з 
                    домену (Heroku), що відрізняється. Щоб отримати відповідь, що надходить з API, веб-сервер 
                    на якому реалізовано API, повинен містити відповідні CORS-заголовки.
                </p>
                <p>
                    Механізм CORS робить безпечні перехресні запити та передачі даних між web-браузерами та web-серверами.
                </p>
                <p>Приклад:</p>
                <pre>
npm install cors

const express = require('express');
const cors = require('cors');
const app = express();
app.use(cors());

app.get('/', (req, res, next) => {
    res.json({ message: 'CORS is activated' });
});
app.listen(3000, function () {
    console.log('CORS-enabled web server listening on port 3000');
});

                </pre>
                <p>
                    У функцію проміжного ПЗ cors, ми можемо передати аргумент – конфігураційний об'єкт з наступними властивостями
                </p>
                <ol>
                    <li>
                        <code>origin:</code> Налаштовує заголовок CORS Access-Control-Allow-Origin. 
                        Найчастіше це рядок "*", який дозволяє запит від будь-якого домену. Можливо конкретне значення 
                        на кшталт "http://example.com" і будуть дозволені тільки запити з "http://example.com". 
                        Можна використовувати регулярний вираз або масив рядків, або регулярних виразів, якщо 
                        доступ до API можливий з різних доменів
                    </li>
                    <li>
                        <code>methods:</code>
                         Налаштовує заголовок CORS Access-Control-Allow-Methods. Очікує рядок з HTTP методами, 
                         наприклад, "GET, PUT, POST", можна масив ['GET', 'PUT', 'POST'], яким дозволені 
                         міждоменні запити.
                    </li>
                    <li>
                        <code>allowedHeaders:</code> Налаштовує заголовок CORS Access-Control-Allow-Headers. 
                        Чекає рядок з роздільниками-комами, наприклад, "Content-Type, Authorization" або 
                        масив ['Content-Type', 'Authorization'] – які заголовки дозволені при запиті.
                    </li>
                    <li>
                        <code>exposedHeaders:</code> Налаштовує заголовок CORS Access-Control-Expose-Headers. Управляє заголовками користувача.
                    </li>
                    <li>
                        <code>credentials:</code> Налаштовує заголовок CORS Access-Control-Allow-Credentials. 
                        Встановіть true для передачі заголовка, інакше він не вказується.
                    </li>
                    <li>
                        <code>maxAge:</code>  Налаштовує заголовок CORS Access-Control-Max-Age. 
                        Встановіть ціле число для передачі заголовка, інакше він не вказується.
                    </li>
                    <li>
                        <code>preflightContinue:</code> Надіслати відповідь попередньої перевірки CORS наступному обробнику.
                    </li>
                    <li>
                        <code>optionsSuccessStatus:</code> Надає код стану для використання у разі 
                        успішних OPTIONS запитів, оскільки деякі застарілі браузери (IE11, різні SmartTV) 
                        не працюють зі статусом 204.
                    </li>
                    <li>
                        Конфігурація за замовчуванням еквівалентна:
                        <pre>
    {
        origin: '*',
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        preflightContinue: false,
        optionsSuccessStatus: 204
    }
                        </pre>
                    </li>
                </ol>
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>Формування URL для REST API</h2>
                <p>
                    У цьому розділі ми поговоримо про правильне іменування ресурсів для API. 
                    Коли ресурси названі правильно, API інтуїтивно зрозумілий та простий у використанні. 
                    Часто кінцеві URL за запитом ресурсу називають endpoints API
                </p>
                <p>Що є хорошою практикою для правильного іменування?</p>
                <ul>
                    <li>Ну, по-перше, необхідно використовувати для опису базових URL іменники у множині – users, contacts.</li>
                    <li>Також потрібно використовувати конкретніші та чіткіші імена news, videos, а не абстрактні items або elements</li>
                    <li>Складну логіку для URL необхідно описувати за рахунок додаткових властивостей, тобто ховати за знаком ?</li>
                    <li>Приклад використання пагінації /users?limit=25&offset=50, фільтрація відповіді /friends?fields=id,name,picture
                    </li>
                </ul>
                <p>Pозглянемо хороші практики іменування URL для різноманітних ситуацій</p>
                <ul>
                    <li>
                        Додавання нового клієнта до системи:
                        <pre>
    HTTP метод: POST
    URL: http://www.example.com/customers
                        </pre>
                    </li>
                    <li>
                        Отримати дані клієнта з ідентифікатором клієнта ID 112233:
                        <pre>
    HTTP метод: GET
    URL: http://www.example.com/customers/112233
                        </pre>
                    </li>
                    <li>
                        Створення нового продукту:
                        <pre>
    HTTP метод: POST
    URL: http://www.example.com/products
                        </pre>
                    </li>
                    <li>
                        Для читання, оновлення, видалення продукту з ID 432111, відповідно:
                        <pre>
    HTTP метод: GET, PUT, DELETE
    URL: http://www.example.com/products/432111
                        </pre>
                    </li>
                    <li>
                        Створення нового замовлення для клієнта поза контекстом клієнта
                        <pre>
    HTTP метод: POST
    URL: http://www.example.com/orders
                        </pre>
                    </li>
                    <li>
                        Створення того самого замовлення, але в контексті конкретного клієнта з ID 332244
                        <pre>
    HTTP метод: POST
    URL: http://www.example.com/customers/332244/orders
                        </pre>
                    </li>
                    <li>
                        Список замовлень, що належать клієнту ID 332244:
                        <pre>
    HTTP метод: GET
    URL: http://www.example.com/customers/332244/orders
                        </pre>
                    </li>
                    <li>
                        Нехай необхідний URL для додавання нової позиції на замовлення з ID 1234, для клієнта з ID 332244:
                        <pre>
    HTTP метод: POST
    URL: http://www.example.com/customers/332244/orders/1234/lineorders
                        </pre>
                    </li>
                    <li>
                        Отримання списку замовлення за ID замовлення без знання ID конкретного клиента
                        <pre>
    HTTP метод: GET
    URL: http://www.example.com/orders/8769
                        </pre>
                    </li>
                    <li>
                        Пагінація здійснюється через query рядок за допомогою параметра offset – це початковий номер позиції, 
                        та параметра limit – максимальна кількість елементів, що повертаються. Вони можуть називатися й 
                        інакше, наприклад skip, limit
                        <pre>
    HTTP метод: GET
    URL: http://api.example.com/resources?offset=0&limit=25
                        </pre>
                    </li>
                    <li>
                        Складна фільтрація за значеннями. Можна використовувати роздільник подвійна двокрапка <code>::</code>, 
                        що відокремлює ім'я властивості від значення порівняння
                        <pre>
    HTTP метод: GET
    URL: http://www.example.com/users?filter="name::sam|city::denver"
                        </pre>
                    </li>
                    <li>
                        Сортування. Один із способів, коли для кожної переданої властивості здійснюється сортування в порядку 
                        зростання, а для кожної властивості, з префіксним тире ("-") сортування здійснюється у порядку зменшення. 
                        Сепаратор для кожного імені властивості вертикальна смуга ("|")
                        <pre>
    HTTP метод: GET
    URL: http://www.example.com/users?sort=lastName|firstName|-birthdate
                        </pre>
                    </li>
                </ul>
            </div>
        </section>




        <section class="section-about">
            <div class="container">
                <h2>Приклад REST API програми</h2>
                <p>
                    Розглянемо найпростіше Web-API. Реалізуємо стандартний todo-list, який буде нам повертати 
                    список поточних завдань. Наш API міститиме повний набір CRUD (Create, Read, Update, Delete) 
                    операцій для наших завдань.
                </p>
                <p>Ми будемо працювати з двома URL</p>
                <ul>
                    <li><code>/api/tasks/</code>  - повний CRUD</li>
                    <li><code>/api/tasks/:id/status</code> - для зміни статусу завдання, виконано воно чи ні</li>
                    <li>Повний код застосунку: 
                        <a href="https://glitch.com/~nodebook-api" target="_blank">glitch.com/~nodebook-api</a>
                    </li>
                    <li>Всі запити до нашого API ми будемо виконувати за допомогою утиліти</li>
                </ul>
                <h4>Основний файл застосунку</h4>
                <pre>
    const express = require('express');
    const cors = require('cors');
    const routerApi = require('./api');
    const app = express();
    app.use(express.json()); // parse application/json
    app.use(cors()); // cors
    app.use('/api', routerApi);

    app.use((_, res, __) => {
        res.status(404).json({
            status: 'error',
            code: 404,
            message: 'Use api on routes: /api/tasks',
            data: 'Not found',
        });
    });
    app.use((err, _, res, __) => {
        console.log(err.stack);
        res.status(500).json({
            status: 'fail',
            code: 500,
            message: err.message,
            data: 'Internal Server Error',
        });
    });
    const PORT = process.env.PORT || 3000;

    app.listen(PORT, function () {
        console.log(Server running. Use our API on port: ${PORT});
    });
                </pre>
                <p>
                    Ми тут підключаємо обробку даних у форматі JSON, включаємо cors і додаємо обробники помилок
                </p>
                <h3>Реалізація API</h3>
                <p>У файлі роутингу ми описуємо всю логіку поведінки нашого API.</p>
                <p>
                    Усі дані про завдання ми зберігаємо у масиві tasks, де жорстко прописуємо одне завдання.
                </p>
                <pre>
    let tasks = [
        {
            id: nanoid(),
            title: 'Work',
            text: 'Do it!',
            done: false,
        },
    ];
                </pre>
                <p>Надалі в цей масив ми будемо додавати нові завдання, видаляти та оновлювати їх</p>

                <h4>Читання</h4>
                <p>отримання списку всіх завдань</p>
                <pre>
    router.get('/tasks', (req, res, next) => {
        res.json({
            status: 'success',
            code: 200,
            data: {
            tasks,
            },
        });
    });
                </pre>
                <p>
                    Тут все досить просто ми віддаємо об'єкт зі статусом 'success', кодом 200 та властивістю data, 
                    це наше корисне навантаження, куди ми покладемо масив наших завдань.
                </p>

                <p>Обробник для отримання завдання за ID</p>
                <pre>
    router.get('/tasks/:id', (req, res, next) => {
        const { id } = req.params;
        const [task] = tasks.filter(el => el.id === id);
        res.json({
            status: 'success',
            code: 200,
            data: { task },
        });
    });
                </pre>

                <h4>Створення нового завдання</h4>
                <pre>
router.post('/tasks', (req, res, next) => {
    const { title, text } = req.body;
    const task = {
        id: nanoid(),
        title,
        text,
        done: false,
    };
    tasks.push(task);
    res.status(201).json({
        status: 'success',
        code: 201,
        data: { task },
    });
});

//body:
{
    "title": "Vacation",
    "text": "Enjoy"
}
                </pre>

                <h4>Оновлення завдання</h4>
                <pre>
    router.put('/tasks/:id', (req, res, next) => {
        const { id } = req.params;
        const { title, text } = req.body;
        const [task] = tasks.filter(el => el.id === id);
        task.title = title;
        task.text = text;
        res.json({
            status: 'success',
            code: 200,
            data: { task },
        });
    });
                </pre>

                <h4>Часткове оновлення</h4>
                <p>Для статусу ми використовуємо окремий URL та HTTP метод PATCH</p>
                <pre>
    router.patch('/tasks/:id/status', (req, res, next) => {
        const { id } = req.params;
        const { done } = req.body;
        const [task] = tasks.filter(el => el.id === id);
        task.done = done;
        res.json({
            status: 'success',
            code: 200,
            data: { task },
        });
    });
                </pre>
                <p>Тут для завдання ми змінюємо значення лише його властивості done</p>
                <pre>
    {
        "done": true
    }
                </pre>

            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2></h2>   
            </div>
        </section>



    </main>
    <footer class="page-footer">
        <div class="container">
        </div>
    </footer>

    <script src="../../js-exampl/btn-top.js"></script>
    <!-- <script src="../../js/xxx.js" type="module"></script> -->
</body>
</html>