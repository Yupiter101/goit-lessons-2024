<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../css/styles-basic.css">
    <link rel="stylesheet" href="../css/styles-animation.css">
</head>

<body>
    <header>
        <div>
            <a class="fixed-back" href="../index.html">Back to main page</a>

            <nav>
            </nav>
        </div>
    </header>

    <main>
        <section class="section-title">
            <div class="container">
                <h1>Animation, trasition</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Позиційовані елементи</li>
                    <li>Властивість z-index</li>
                    <li>Властивість overflow</li>
                    <li>Заокруглене зображення</li>
                    <li>Декоративний оверлей</li>
                    <li>CSS-переходи -transition-</li>
                    <li>Анімовані властивості - opacity і transform</li>
                    <li>Перспектива</li>
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Позиційовані елементи</h2>
                <figure>
                    <!-- Довільний графічний контент: фотографія, графік, діаграма тощо -->
                    <img src="../img/relativ.JPG" alt="position"/>
                    <figcaption><code>position: static | relative | absolute | fixed | sticky | inherit</code></figcaption>
                </figure>
                <p>За замовчуванням елементи на сторінці розташовуються зліва направо і зверху вниз. А як зробити напис на
                     зображенні товару, показати один елемент поверх іншого при ховері або змусити меню завжди бути прикріпленим 
                     до верхньої частини в'юпорту, навіть під час скролу? Для вирішення подібних завдань існує властивість position, 
                     що дозволяє буквально підняти елемент і розмістити його поверх будь-якого іншого.
                     Статичне позиціонування (static) - це початковий стан всіх елементів веб-сторінки. Блокова модель і флексбокс 
                     розташовують елементи саме в цьому статичному потоці сторінки. Відносне (relative), абсолютне (absolute) і
                     фіксоване (fixed) позиціонування дозволяють підняти елемент над потоком сторінки і вручну його позиціонувати, 
                     використовуючи систему координат, початок якої залежить від типу позиціонування
                </p>   

                <h3>Властивість position</h3>
                <ul>
                    <li>
                        <code>position: static</code>
                        <p>За замовчуванням встановлено значення static. Для зазначення положення 
                            елемента використовуються властивості top, left, bottom або right, які застосовуються до елементів без position</p>
                    </li>

                    <li>
                        <br>
                        <code>position: relative</code>
                        <p>Елемент, значення властивості position якого відрізняється від static, називається «позиційований елемент»
                        Під час використання відносного позиціонування елемент залишається 
                        в потоці сторінки, тобто сусідні елементи не займають його місце. Проте, візуально елемент можна зсунути щодо його 
                        оригінального положення, водночас він може перекривати сусідів/
                        Властивості top, left, bottom і right дозволяють вказати зміщення елемента (візуальне) щодо його вихідного положення. 
                        Можуть приймати від'ємні значення.
                        </p>
                    </li>

                    <li>
                        <br>
                        <code>position: absolute</code>
                        <p>Під час використання абсолютного позиціонування елемент виривається з потоку сторінки, тобто сусідні елементи 
                        займають його місце. Відлік значень top, left, bottom і right для абсолютно позиційованого елемента ведеться 
                        <b>щодо найближчого предка з позиціонуванням, відмінного від статичного.</b> Якщо такого предка не буде, то відлік буде 
                        здійснюватися від меж елемента body
                        </p>
                        <div class="thumb-img">
                            <img src="https://images.pexels.com/photos/2558605/pexels-photo-2558605.jpeg?auto=compress&cs=tinysrgb&dpr=2&&w=320" alt="adorable-animal-blur-cat">
                            <p class="label-img">Cat</p>
                        </div>
                    </li>

                    <li>
                        <br>
                        <code>position: fixed</code>
                        <p>У разі фіксованого позиціонування, елемент вилучається з потоку сторінки <b>і позиціонується щодо в'юпорту 
                            (вікна браузера)</b>. Це створює ефект фіксації елемента в певному місці екрану при прокручуванні сторінки
                        </p>
                        <p>
                            Фіксоване позиціонування використовується для закріплених хедерів з навігацією, спливаючих вікон, чатів з 
                            менеджером на сторінках інтернет-магазинів тощо.
                        </p>
                        <button class="fixed-button"></button>
                    </li>

                    <li>
                        <br>
                        <code>position: sticky</code>
                        <p>Липке позиціонування. Фіксед тримається поки є його контейнер в полі видимості.
                            Як тільки зявляється новий контейне буде новий фікскд
                        </p>
                        <p>Для реалізації липкого позиціонування необхідні всього три умови:</p>
                        <ol>
                            <li>
                                У липкого елемента повинно бути встановлено позиціонування position: sticky.
                            </li>
                            <li>
                                У липкого елемента повинно бути встановлено положення, наприклад top: 0.
                            </li>
                            <li>
                                Елемент-контейнер повинен бути більшим по висоті за липкий елемент.
                            </li>
                        </ol>
                        <p><a href="https://codepen.io/goit-academy/pen/pogXLWz" target="_blank">Приклад</a></p>
                    </li>
                </ul>

                <h2>Властивість z-index</h2>
                
                <figure>
                    <img src="../img/z-index.JPG" alt="z-index"/>
                    <figcaption><code>z-index: -1;</code></figcaption>
                </figure>

                <p>
                    У прикладі, div.container з відносним позиціонуванням - це спільний предок для 
                    чотирьох div.box, які позиціоновані у ньому абсолютно. Використовуючи властивість z-index, 
                    можна змінити їх порядок відображення на осі z
                </p>

                <div class="z-container">
                    <div class="z-box">1</div>
                    <div class="z-box">2</div>
                    <div class="z-box">3</div>
                    <div class="z-box">4</div>
                </div>    
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Властивість overflow</h2>
                <p>
                    Але що буде, якщо висота або ширина вказані явно? Тоді блок не може збільшитися, 
                    і вміст його переповнює - виходить за межі. Властивість overflow управляє тим, як 
                    поводиться вміст елемента, якщо його розмір перевищує допустиму довжину або ширину.
                </p>
                <p><code>overflow: visible | hidden | scroll | auto</code></p>
                <ul>
                    <li>
                        <h3><code>overflow: visible</code></h3>
                        <a href="https://codepen.io/goit-academy/pen/vYLaJeM" target="_blank">visible</a> - видимий 
                        переповнюючий вміст. Значення за замовчуванням.
                        <div class="box-visible">
                            Тут важливо пам'ятати, що навіть, якщо зовні елемента є видимий контент, що його переповнює, 
                            цей контент не впливає на геометрію сусідніх елементів як з кнопкою в прикладі.
                        </div>
                        <br>
                    </li>

                    <li>
                        <h3><code>overflow: hidden</code></h3>
                        <a href="https://codepen.io/goit-academy/pen/PoZBKBq" target="_blank">hidden</a> - все, що виходить 
                        за межі блоку, буде візуально приховане.
                        <div class="box-hidden">
                            Протилежне значення hidden. У цьому випадку будь-який переповнюючий вміст, який виходить за 
                            межі елемента, не відображається. Така поведінка зручна для використання з декоративними ефектами, 
                            приклади яких ми розглянемо далі
                        </div>
                        <br>
                    </li>

                    <li>
                        <h3><code>overflow: scroll</code></h3>
                        <a href="https://codepen.io/goit-academy/pen/xxZJLay" target="_blank">scroll</a> - з'являються горизонтальна і вертикальна 
                        смуги прокручування
                        <div class="box-scroll">
                            Якщо встановлене значення scroll, переповнюючий вміст буде прихований, але з'являться скроллбари, 
                            щоб була можливість переглянути увесь контент. Водночас будуть показані обидва скроллбари - горизонтальний 
                            і вертикальний, навіть якщо потрібен тільки якийсь один.
                        </div>
                        <br>
                    </li>
                    
                    <li>
                        <h3><code>overflow: auto</code></h3>
                        <a href="https://codepen.io/goit-academy/pen/dyGjzaE" target="_blank">auto</a>
                        <div class="box-auto">
                            Значення auto схоже на значення scroll, за винятком того, що показуються тільки 
                            ті смуги прокручування, які дійсно необхідні
                        </div>
                        <br>
                    </li>
                        Також існують властивості overflow-x і overflow-y, які управляють переповненням тільки 
                        у відповідній площині.
                    </li>
                    <li>
                        <h3>Заокруглене зображення</h3>
                        <div class="thumb-hidden">
                            <img src="https://images.pexels.com/photos/33492/cat-red-cute-mackerel.jpg?auto=compress&cs=tinysrgb&h=480&w=640" alt="ft">
                        </div>
                        <p><code>border-radius: 50px; overflow: hidden;</code></p>
                        <br>
                    </li>

                    <li>
                        <h3>Декоративний оверлей</h3>
                        <div class="box-overlay">
                            <div class="overlay">
                                <p>
                                    overlay 
                                    <code>
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        width: 100%;
                                        height: 100%;
                                        transform: translateX(100%);
                                        transition: transform 250ms ease-in-out;
                                    </code>
                                </p>
                            </div>
                        </div>
                    </li>
                </ul> 
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>CSS-переходи</h2>
                <ul>
                    <li><code>transition-property: <b>all</b> | background-color | transform | ...</code></li>
                    <li><code><a href="https://codepen.io/goit-academy/pen/yLexwPr" target="_blank">transition-duration</a>: 1000ms; | 1s;</code></li>
                    <li><code>transition-timing-function: linear | <b>ease</b> | ease-in | ease-out| ease-in-out</code></li>
                    <li><code>transition-timing-function: cubic-bezier(0.39, 1.03, 0.82, 0.08);</code></li>
                    <li><code>transition-delay: <b>0s</b> | 500ms</code> затримка </li>
                    <li>або просто transition</li>
                    <li><code>transition: [property] [duration] [timing-function] [delay]</code></li>
                    <li><code>transition: background-color 500ms linear, transform 500ms ease-in-out;</code></li>
                    <li>    
                        <h4>Приклад transition</h4>
                        <div class="container-transition">
                            <div class="circle">linear</div>
                            <div class="circle">ease</div>
                            <div class="circle">ease-in</div>
                            <div class="circle">ease-out</div>
                            <div class="circle">ease-in-out</div>
                            <div class="circle">cubic-bezier</div>
                        </div>
                        <ul>
                            <li>Code:</li>
                            <li><code>transform: translatex(0);</code></li>
                            <li><code>transition-property: transform;</code></li>
                            <li><code>transition-duration: 1000ms;</code></li>
                            <li><code>transition-delay: 200ms;</code></li>
                            <li><code>:hover .circle</code></li>
                            <li><code>transform: translatex(calc(800px - 110px - 20px));</code></li>
                        </ul>
                    </li>
                    <li>
                        <h4>Приклад-2 transition</h4>
                        <div class="container-transition-2">
                            <p>rotate(90deg)</p>
                        </div>
                        <ul>
                            <li>Code:</li>
                            <li><code>background-color: yellowgreen;</code></li>
                            <li><code>transition: background-color 1000ms linear 200ms, transform 200ms linear;</code></li>
                            <li>container-transition-2:hover</li>
                            <li><code>background-color: red;</code></li>
                            <li><code>transform: rotate(90deg);</code></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Анімації - opacity і transform</h2>
                <ul>
                    <li>
                        Як і переходи, анімація надає веб-сторінкам динамічність, але, на відміну від переходів, анімації не потрібен обов'язковий 
                        ініціатор (подія), її можна повторити нескінченну кількість разів, і між початковим і кінцевим станами може бути будь-яка 
                        кількість проміжних станів.
                    </li>
                    <li>
                        Анімація оголошується директивою <code>@keyframes</code>, яка дозволяє описати набір кадрів (frames, станів) анімації, яких повинно бути 
                        як мінімум два (початковий і кінцевий).
                    </li>
                    <li>
                        В анімації не вказується час або елемент, до якого вона буде застосовуватися, це означає, що одну і ту саму анімацію можна використовувати 
                        повторно для різних елементів.
                    </li>
                </ul>

                <h3>Властивості анімації</h3>
                <ul>
                    <li><code>.box {
                        animation-name: changeBgColor;
                      }</code></li>

                    <li><code>.box:hover {
                        animation-name: changeBgColor;
                      }</code></li>

                    <li><code>animation-name: animetionBgColor;</code></li>
                    <li><code>animation-duration: 3000ms;</code></li>
                    <li><code>animation-timing-function: linear;</code></li>
                    <li><code>animation-delay: 1000ms;</code></li>
                    <li><code>animation-iteration-count: 5;</code> - кількість повних повторень анімації.</li>
                    <li><code>animation-iteration-count: infinite;</code> - це зробить анімацію нескінченною.</li>
                    <li><code>animation-direction: normal | reverse | alternate | alternate-reverse;</code>
                        <ul>
                            <li>normal - анімація відтворюється від початкового до кінцевого кадру, після чого відразу повертається у початковий кадр для 
                                наступного повторення (скидається до початкового стану). Це значення за замовчуванням
                            </li>
                            <li>
                                reverse - анімація відтворюється у зворотному напрямку, починаючи від кінцевого кадру і до початкового, після чого відразу 
                                повертається у кінцевий кадр для наступного повторення.
                            </li>
                            <li>
                                alternate - перший раз відтворення починається від початкового і до кінцевого кадру, після чого відбувається зміна напрямку 
                                на кожному наступному повторенні.
                            </li>
                            <li>
                                alternate-reverse - перший раз відтворення починається від кінцевого і до початкового кадру, після чого відбувається зміна 
                                напрямку на кожному наступному повторенні.
                            </li>
                            <li></li>
                            <li></li>
                            <li></li>
                            <li></li>
                        </ul>
                    </li>

                    <li><code>animation-fill-mode: none | forwards | backwards | both</code>
                        <ul>
                            <li>
                                none - стилі анімації впливають на елемент тільки під час анімації. До і після анімації елемент знаходиться у своєму початковому 
                                стані. Значення за замовчуванням.
                            </li>
                            <li>
                                forwards - стилі, застосовані в кінці анімації, залишаються на елементі після її завершення
                            </li>
                            <li>
                                backwards - стартові стилі анімації будуть застосовані до елемента ще до старту анімації.
                            </li>
                            <li>
                                both - поєднує forwards і backwards, стилі застосовуються до і після анімації
                            </li>
                            <li></li>
                        </ul>
                    </li>

                    <li><code>animation-play-state: <b>running</b> | paused</code>Можна зупинити анімацію</li>
                    <li>
                        <code>
                            animation: [name] [duration] [timing-function] [delay] [iteration-count] [direction] [fill-mode] [play-state]
                        </code>
                    </li>
                    <li>
                        За замовчуванням анімація відбувається один раз і фінальні значення анімованих властивостей не зберігаються, натомість елемент повертається 
                        до свого вихідного стану.
                    </li>
                    <li>
                        <h4>@keyframes</h4>
                        <div class="img-container-keyframe">
                            <img src="../img/keyframes.jpg" alt="keyframes">
                            <img src="../img/keyframes-rot.jpg" alt="keyframes">
                        </div>
                        
                    </li>
                    <li>
                        <div class="animation-box hov">hover</div>
                        <ul>
                            <li>Code:</li>
                            <li><code>animation-name: animetionBgColor;</code></li>
                            <li><code>animation-duration: 3000ms;</code></li>
                        </ul>
                    </li>
                    <li>
                        <div class="animation-box cons">only start</div>
                    </li>
                    <ul>
                        <li>Code:</li>
                        <li><code>animation-name: animetionBgColor;</code></li>
                        <li><code>animation-duration: 3000ms;</code></li>
                        <li><code>animation-timing-function: linear;</code></li>
                        <li><code>animation-delay: 1000ms;</code></li>
                        <li><code>animation-iteration-count: 5;</code></li>
                        <li>Або <code>animation-iteration-count: infinite;</code></li>
                    </ul>
                </ul>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Перспектива</h2>
                <!-- perspective -->
                <div class="perspective-wrap">
                    <div class="scene">
                      <div class="box-per rotate-x"></div>
                    </div>
                  
                    <div class="scene">
                      <div class="box-per rotate-y"></div>
                    </div>
                </div>

                <ul>
                    <li><code>transform: perspective(400px) rotateX(0deg);</code></li>
                    <li><code>transform: perspective(400px) rotateX(60deg);</code></li>
                    <li><code>transform: perspective(400px) rotateY(0deg);</code></li>
                    <li><code>transform: perspective(400px) rotateY(60deg);</code></li>
                    <li></li>
                </ul>
                <h4>Властивість <a href="https://codepen.io/goit-academy/pen/NWxZNyY" target="_blank">perspective</a></h4>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>2D-трансформації</h2>
                <p>
                    CSS-трансформації дозволяють зсувати, змінювати масштаб і повертати елементи, тобто додавати декоративні ефекти. Трансформації змінюють форму 
                    і положення елемента, не впливаючи на інші елементи сторінки. За замовчуванням трансформація відбувається щодо центру елемента, але це можна
                     змінити.
                </p>
                <h3>Властивість transform</h3>
                <p>transform: none | тип трансформації тип трансформації ...</p>
                <ul>
                    <li><code>transform: scaleX(tx), scaleY(ty) і scale(tx, ty)</code></li>
                    <li>не впливаючи на геометрію елементів. Якщо для scale() вказано одне значення, друге буде таке саме.</li>
                    <li>transform: rotate(45deg);</li>
                    <li>transform: translate(100px, 200px);</li>
                    <li>
                        Центрування елемента
                        <div class="parent-box">
                            <div class="center-box"></div>
                        </div>
                    </li>
                    <li><code>position: absolute;</code></li>
                    <li><code>top: 50%;</code></li>
                    <li><code>left: 50%;</code></li>
                    <li><code>transform: translate(-50%, -50%);</code></li>
                    <li><code></code></li>
                </ul>
                <h3>Перелік методів transform:</h3>
                <ul>
                    <li><code>transform: <a href="https://codepen.io/goit-academy/pen/RwrBQwP" target="_blank">scale</a>(1.15);</code></li>
                    <li><code>transform: <a href="https://codepen.io/goit-academy/pen/BajPxRa" target="_blank">rotate</a>(45deg);</code></li>
                    <li><code>transform: <a href="https://codepen.io/goit-academy/pen/OJMwzYX" target="_blank">translate</a> (100px, 200px);</code></li>
                    <li><code>transform: <a href="https://codepen.io/goit-academy/pen/KKVBByO" target="_blank">translate</a>(-50%, -50%);</code> Центрування</li>
                    <li><code></code></li>
                </ul>
            </div>
        </section>

    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
                <p>address</p>
            </address>
        </div>
    </footer>
</body>
</html>