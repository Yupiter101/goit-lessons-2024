<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS-DOM</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
</head>

<body>
    <header>
        <div>
            <a  class="fixed-back" href="../../index.html">Back to main page</a>
            <nav>
            </nav>
        </div>
    </header>

    <main>
        <section class="section-title">
            <div class="container">
                <h1>JS DOM and Event</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Об'єктна модель документа</li>
                    <li>Навігація по DOM</li>
                    <li>Пошук елементів</li>
                    <li>Властивості та атрибути</li>
                    <li>Властивість textContent</li>
                    <li>Властивість classList</li>
                    <li>Властивість style</li>
                    <li>Атрибути</li>
                    <li>Створення та видалення елементів</li>
                    <li>Оптимізація роботи з DOM</li>
                    <li>Властивість innerHTML</li>
                    <li>Метод insertAdjacentHTML()</li>
                    <li>Підключення скриптів</li>
                    <li>Атрибут defer</li>
                    <li>Атрибут async</li>
                    <li>Події</li>
                    <li>Метод addEventListener()</li>
                    <li>Метод removeEventListener()</li>
                    <li>Ключове слово this</li>
                    <li>Об'єкт події</li>
                    <li>Дії браузера за замовчуванням - preventDefault()</li>
                    <li>Form</li>
                    <li>Події клавіатури</li>
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Список основних методів</h2>
                <ul>
                    <li>= document.querySelector('#menu');</li>
                    <li>= document.querySelector('.menu');</li>
                    <li>= document.querySelectorAll("li");</li>
                    <li>= document.querySelectorAll(".menu-item");</li>
                    <li>menu = document.querySelector(".menu-item");</li>
                    <li>menu.style.textTransform = 'uppercase';</li>
                </ul>
                
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Об'єктна модель документа</h2>
                <p>
                    Об'єктна модель документа (Document Object Model) - незалежний від мови інтерфейс для роботи 
                    з HTML-документом. Містить набір властивостей і методів, що дозволяють шукати, створювати 
                    і видаляти елементи, реагувати на дії користувача і багато іншого. Тобто з'єднує сторінку 
                    з мовою програмування.
                </p>
                <p>
                    DOM - це відображення HTML-документа, деревоподібна структура, в якій кожен вузол - 
                    це JavaScript-об'єкт з властивостями і методами, що становить частину HTML-документа. 
                    Кожен елемент в документі, весь документ в цілому, заголовок, посилання, абзац - 
                    це частини DOM цього документа, тому всі вони можуть бути змінені з JavaScript-коду.
                </p>
                <p>
                    Об'єктна модель браузера (Browser Object Model) - незалежний від мови інтерфейс для 
                    роботи з вкладкою браузера. Містить набір властивостей і методів, що дозволяють отримати 
                    доступ безпосередньо до поточної вкладки і ряду функцій браузера. Містить об'єкт роботи з 
                    історією навігації, місцем розташування та багато іншого.
                </p>
                <div>
                    <img src="../../img/js-dom.jpg" alt="js-dom.img" width="400">
                </div>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Навігація по DOM</h2>
                <p>
                    document - це частина глобального об'єкта window, який доступний у скрипті, 
                    коли він виконується в браузері. Так само як alert, console.log, prompt і багато інших.
                </p>
                <p>
                    Найвищий елемент називається кореневим (root node).
                </p>
                <p>
                    Для навігації по цій ієрархії елементи мають наступні властивості:
                </p>
                <ul>
                    <li>elem.parentNode - вибере батьківський elem.</li>
                    <li>elem.childNodes - псевдомасив, зберігає всі дочірні елементи, включно з текстовими.</li>
                    <li>elem.children - псевдомасив, зберігає тільки дочірні вузли-елементи, тобто ті, що відповідають тегам.</li>
                    <li>elem.firstChild - вибере перший дочірній елемент всередині elem, включно з текстовими вузлами.</li>
                    <li>elem.firstElementChild - вибере перший дочірній вузол-елемент всередині elem.</li>
                    <li>elem.lastChild - вибере останній дочірній елемент всередині elem, включно з текстовими вузлами.</li>
                    <li>elem.lastElementChild - вибере останній дочірній вузол-елемент всередині elem.</li>
                    <li>elem.previousSibling - вибере елемент «зліва» від elem (його попереднього сусіда).</li>
                    <li>elem.previousElementSibling - вибере вузол-елемент «зліва» від elem (його попереднього сусіда).</li>
                    <li>elem.nextSibling - вибере елемент «праворуч» від elem (його наступного сусіда)</li>
                    <li>elem.nextElementSibling - вибере вузол-елемент «праворуч» від elem (його наступного сусіда).</li>
                </ul>
                <h4><a href="https://codepen.io/goit-academy/pen/oNZqxoP" target="_blank">Приклад 1</a> коду js</h4>
                <pre>
    &lt;ul class="list"&gt;
        &lt;li&gt;First item&lt;/li&gt;
        &lt;li&gt;Second item&lt;/li&gt;
        &lt;li&gt;Third item&lt;/li&gt;
        &lt;li&gt;Fourth item&lt;/li&gt;
        &lt;li&gt;Fifth item&lt;/li&gt;
    &lt;/ul&gt;
                </pre>

                <pre>
    console.log(document);

    const body = document.body;
    console.log(body);

    const list = document.querySelector(".list");
    console.log(list);

    const firstListItem = list.firstElementChild;
    console.log(firstListItem);

    const lastListItem = list.lastElementChild;
    console.log(lastListItem);

    const listItems = list.children;
    console.log(listItems);
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Пошук елементів</h2>
                <p>
                    Отже, ми вже знаємо що DOM-елемент - це об'єкт з властивостями і методами. 
                    Саме час навчитися швидко знаходити елемент за довільним CSS-селектором. 
                    Група методів elem.querySelector* - це сучасний стандарт для пошуку елементів. 
                    Вони дозволяють знайти елемент або групу елементів за CSS-селектором будь-якої складності.
                </p>
                <code>element.querySelector(selector);</code>
                <ul>
                    <li>
                        Використовується, якщо необхідно знайти тільки один, найчастіше унікальний елемент.
                    </li>
                    <li>
                        Повертає перший знайдений елемент всередині element, що відповідає CSS-селектору selector.
                    </li>
                    <li>
                        Якщо нічого не знайдено, поверне null.
                    </li>
                </ul>

                <code>element.querySelectorAll(selector);</code>
                <ul>
                    <li>
                        Використовується, якщо необхідно знайти колекцію елементів, тобто отримати масив 
                        посилань на елементи з однаковим селектором. Наприклад, всі елементи списку з класом 
                        menu-item
                    </li>
                    <li>
                        Повертає псевдомасив всіх елементів всередині element, які відповідають CSS-селектору selector.
                    </li>
                    <li>
                        Якщо нічого не знайдено, поверне порожній масив.
                    </li>
                </ul>

                <h4><a href="https://codepen.io/goit-academy/pen/wvJmGbG" target="_blank">Приклад 2</a> коду js</h4>
                <pre>
    &lt;ul id="menu" class="menu"&gt;
        &lt;li class="menu-item"&gt;home&lt;/li&gt;
        &lt;li class="menu-item"&gt;about&lt;/li&gt;
        &lt;li class="menu-item"&gt;gallery&lt;/li&gt;
        &lt;li&gt;blog&lt;/li&gt;
    &lt;/ul&gt;
                </pre>

                <pre>
    const listWithId = document.querySelector('#menu');
    listWithId.style.textTransform = 'uppercase';
    listWithId.style.fontSize = '24px';
    console.log(listWithId);

    const listWithClass = document.querySelector('.menu');
    console.log(listWithClass);

    const menuItemsByTagName = document.querySelectorAll("li");
    console.log(menuItemsByTagName);

    const menuItemsByClass = document.querySelectorAll(".menu-item");
    console.log(menuItemsByClass);

    const firstMenuItem = document.querySelector(".menu-item");
    firstMenuItem.style.color = 'tomato';
    console.log(firstMenuItem);
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Властивості та атрибути</h2>
                <p>
                    Під час побудови DOM-дерева, деякі стандартні HTML-атрибути стають властивостями 
                    елементів. Подивимося на декілька властивостей, які часто використовуються.
                </p>
                <ul>
                    <li>value - містить поточний текстовий контент елементів форм</li>
                    <li>checked - зберігає стан чекбокса або радіокнопки.</li>
                    <li>name - зберігає значення, вказане в HTML-атрибуті name.</li>
                    <li>src - шлях до зображення тегу img.</li>
                </ul>
                <h4>Example</h4>
                <pre>
    &lt;img class="image" 
        src="https://picsum.photos/id/9/320/240" 
        alt="A laptop" 
        width="300" /&gt;
                </pre>
                <div>
                    <img class="image" src="https://picsum.photos/id/9/320/240" 
                        alt="A laptop" 
                        width="300" />
                </div>
                <pre>
    const image = document.querySelector(".image");
    console.log(image.src); // https://picsum.photos/id/9/320/240
    console.log(image.alt); // A laptop

    image.src = "https://picsum.photos/id/13/640/480";
    image.alt = "River bank";
                </pre>

                <h3>Властивість textContent</h3>
                <p>
                    <b>elem.textContent</b> повертає текстовий контент всередині елемента. Доступний для читання
                     і запису. Неважливо, що буде передано в textContent, дані завжди будуть записані 
                     як текст.
                </p>
                <pre>
    const titleEl = document.querySelector(".article-title");
    titleEl.textContent = 'Welcome to Bahamas!';
                </pre>

                <h3>Властивість classList</h3>
                <p>
                    У властивості classList зберігається об'єкт з методами для роботи з класами елемента.
                </p>
                <ul>
                    <li>
                        elem.classList.contains(cls) - повертає true або false, залежно від наявності 
                        класу cls в елемента.
                    </li>
                    <li>elem.classList.add(cls) - додає клас cls до списку класів елемента.</li>
                    <li>elem.classList.remove(cls) - видаляє клас cls зі списку класів елемента.</li>
                    <li>
                        elem.classList.toggle(cls) - якщо відсутній клас cls, то додає його, 
                        якщо - присутній, навпаки - видаляє.
                    </li>
                    <li>
                        elem.classList.replace(oldClass, newClass) - замінює існуючий клас 
                        oldClass на вказаний newClass.
                    </li>
                </ul>
                <h4>Example</h4>
                <pre>
    HTML
    &lt;a class="link is-active" href=""&gt;A random link&lt;/a&gt;

    JS
    const link = document.querySelector(".link");
    console.log(link.classList);

    const hasActiveClass = link.classList.contains("is-active");
    console.log(`hasActiveClass - ${hasActiveClass}`);

    link.classList.add("special");
    console.log(link.classList);

    link.classList.remove("is-active");
    console.log(link.classList);

    link.classList.toggle("is-active");
    console.log(link.classList);

    link.classList.replace("special", "regular");
    console.log(link.classList);
                </pre>

                <h3>Властивість style​</h3>
                <p>
                    Використовується для читання та зміни інлайнових стилів. Повертає об'єкт 
                    CSSStyleDeclaration, який містить список усіх властивостей, визначених тільки 
                    у вбудованих стилях елемента, а не увесь CSS. Під час запису властивості записуються 
                    в camelCase, тобто background-color перетворюється на element.style.backgroundColor тощо.
                </p>
                <pre>
    const button = document.querySelector(".btn");

    button.style.backgroundColor = "teal";
    button.style.fontSize = "24px";
    button.style.textAlign = "center";
                </pre>
                <p>
                    На практиці стилізація елементів виконується шляхом додавання CSS-класів. 
                    Властивість style використовується для додавання будь-яких динамічних стилів, 
                    наприклад, під час анімації.
                </p>

                <h3>Атрибути</h3>
                <p>
                    Доступ до атрибутів здійснюється за допомогою стандартних методів. Ці методи працюють 
                    зі значенням, яке знаходиться в HTML.
                </p>
                <ul>
                    <li>
                        elem.hasAttribute(name) - перевіряє наявність атрибута, повертає true або false.
                    </li>
                    <li>elem.getAttribute(name) - отримує значення атрибута і повертає його.</li>
                    <li>elem.setAttribute(name, value) - встановлює атрибут.</li>
                    <li>elem.removeAttribute(name) - видаляє атрибут.</li>
                    <li>elem.attributes - властивість, що повертає об'єкт усіх атрибутів елемента.</li>
                </ul>
                <pre>
    const image = document.querySelector(".image");

    console.log(image.attributes); 
            // NamedNodeMap {0: class, 1: src, 2: alt, length: 3}
    console.log(image.hasAttribute("src")); // true
    console.log(image.getAttribute("alt")); // "Rocks and waterfall"
    image.setAttribute("alt", "Amazing nature");
    console.log(image.getAttribute("alt")); // Amazing
                </pre>

                <h3>data-атрибути</h3>
                <p>
                    Дозволяють додати до тегу довільний атрибут і отримати його значення в JavaScript. 
                    Цю можливість використовують для того, щоб спростити написання коду, наприклад, 
                    зв'язати дані і розмітку за унікальним ідентифікатором, вказати тип дії кнопки тощо
                </p>
                <p>
                    Для отримання значення data-атрибута використовується властивість dataset, 
                    після якого стоїть ім'я атрибута. Тобто data- відкидається, а інша частина імені 
                    записується як ім'я властивості об'єкта.
                </p>
                <pre>
    &lt;button type="button" data-action="save"&gt;Save&lt;/button&gt;

    const saveBtn = document.querySelector('button[data-action="save"]');
    console.log(saveBtn.dataset.action); // "save"
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Створення та видалення елементів</h2>
                <p>
                    DOM API дозволяє не тільки вибирати або змінювати вже існуючі, але й видаляти, 
                    а також створювати нові елементи, після чого додавати їх в документ.
                </p>

                <h3>Створення</h3>
                <pre>
    document.createElement(tagName);
                </pre>
                <p>Елемент створюється в пам'яті, в DOM його ще немає.</p>
                <h3>Додавання</h3>
                <p>
                    Щоб створений елемент відображався на сторінці, його необхідно додати до 
                    вже існуючого елемента в DOM-дереві.
                </p>
                <p>для цього існують методи:</p>
                <ul>
                    <li>
                        element.append(el1, el2, ...) - додає один або декілька елементів 
                        після всіх дітей елемента element.
                    </li>
                    <li>
                        element.prepend(el1, el2, ...) - додає один або декілька елементів 
                        перед усіма дітьми елемента element.
                    </li>
                    <li>
                        element.after(el1, el2, ...) - додає один або декілька елементів після елемента element.
                    </li>
                    <li>
                        element.before(el1, el2, ...) - додає один або декілька елементів перед елементом element.
                    </li>
                </ul>
                <h4>Example</h4>
                <pre>
    &lt;h1&gt;Usernames&lt;/h1&gt;
    &lt;ul class="usernames"&gt;
        &lt;li&gt;Mango&lt;/li&gt;
    &lt;/ul&gt;

    const list = document.querySelector(".usernames");

    const item = document.createElement("li");
    item.textContent = "Poly";
    list.append(item);
                </pre>
                <h2>Перевірити!!!!</h2>
                <p>
                    Якщо елемент для додавання вже знаходиться в DOM, то він видаляється зі свого старого 
                    місця і додається у нове. З цього випливає правило - один і той самий елемент не може 
                    бути одночасно у двох місцях.
                </p>

                <h3>Видалення</h3>
                <pre>
    elem.remove();
                </pre>
                <p>
                    Для того, щоб видалити елемент, використовується метод remove(). 
                    Він викликається на елементі elem, який необхідно видалити.
                </p>
                <h4>Example</h4>
                <pre>
    &lt;p class="text"&gt;Text&lt;/p&gt;

    const text = document.querySelector('.text');
    text.remove();
                </pre>

                <h3>Оптимізація роботи з DOM</h3>
                <p>
                    зміна DOM-дерева - це дорога операція, тому 
                    необхідно намагатися мінімізувати кількість звернень до DOM.
                </p>
                <p>
                    Repaint - відбувається, коли зміни торкнулися стилів, 
                    що впливають на зовнішній вигляд елемента, але не на геометрію.
                </p>
                <p>
                    Reflow - відбувається, коли зміни впливають на вміст, структуру документу, положення елементів. 
                    Відбувається перерахунок позиціонування і розмірів, що призводить до повторного створення 
                    частини або всього документу.
                </p>
                <p>
                    Сторінка не може виконувати жодні інші операції у той час, коли відбувається reflow або repaint.
                </p>
                <p>Причинами можуть бути:</p>
                <ul>
                    <li>Маніпуляції з DOM (додавання, видалення, зміна, перестановка елементів)</li>
                    <li>Зміна вмісту, зокрема тексту в полях форм</li>
                    <li>Розрахунок або зміна CSS-властивостей</li>
                    <li>Додавання і видалення таблиць стилів</li>
                    <li>Маніпуляції з атрибутом class</li>
                    <li>Маніпуляції з вікном браузера (зміни розмірів, прокручування)</li>
                    <li>Активація псевдокласів (наприклад, ':hover')</li>
                </ul>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Властивість innerHTML</h2>
                <p>
                    Ще один спосіб створити DOM-елементи і помістити їх в дерево - це використовувати рядки з 
                    тегами і дозволити браузеру зробити всю важку роботу. У такого підходу є свої плюси і мінуси.
                </p>
                <h3>Читання</h3>
                <p>
                    Властивість innerHTML зберігає вміст елемента, включно з тегами, у вигляді рядка. Значення, 
                    що повертається, - це завжди валідний HTML-код.
                </p>
                <pre>
    const article = document.querySelector(".article");
    console.log(article.innerHTML);
                </pre>

                <h3>Зміна</h3>
                <p>
                    Властивість innerHTML доступна і для читання, і для запису. Якщо записати в неї рядок з 
                    HTML-тегами, то браузер під час парсингу рядка перетворить їх у валідні елементи і 
                    додасть в DOM-дерево.
                </p>
                <pre>
    const title = document.querySelector(".article .title");
    title.innerHTML = 'New and &lt;span class="accent"&gt;improved&lt;/span&gt; title';
                </pre>

                <p>
                    Якщо у властивість innerHTML записати порожній рядок, то вміст елемента буде очищено. 
                    Це простий і швидкий спосіб видалення всього вмісту.
                </p>
                <p>
                    Однотипна (шаблонна) розмітка створюється із масиву даних. Прийом полягає у перебиранні 
                    цього масиву і складанні одного рядка з HTML-тегами, який потім записуємо в innerHTML 
                    елемента.
                </p>
                <pre>
    &lt;ul class="list"&gt;&lt;/ul&gt;

    const technologies = ["HTML", "CSS", "JS", "React", "Node"];
    const list = document.querySelector(".list");

    const markup = technologies
    .map((technology) => `&lt;li class="list-item"&gt;${technology}&lt;/li&gt;`)
    .join("");

    list.innerHTML = markup;
                </pre>

                <h3>Додавання</h3>
                <p>
                    Зміна elem.innerHTML повністю видалить і повторно створить всі нащадки елемента elem. 
                    Якщо елемент спочатку не був порожній, то виникнуть додаткові витрати на серіалізацію 
                    вже існуючої розмітки, а це погано.
                </p>
                <p>
                    Використовуйте властивість elem.innerHTML для додавання тільки тоді, коли елемент elem - 
                    порожній, або якщо потрібно повністю замінити його вміст.
                </p>

                <h3>Метод insertAdjacentHTML()</h3>
                <p>
                    Сучасний метод для додавання рядка з HTML-тегами перед, після або всередину елемента. Вирішує проблему innerHTML з повторною серіалізацією вмісту елемента під час додавання розмітки до вже існуючої.
                </p>
                <pre>
    elem.insertAdjacentHTML(position, string);
                </pre>
                <p>
                    Аргумент position - це рядок, позиція щодо елемента elem. Приймає одне з чотирьох значень
                </p>
                <ul>
                    <li>"beforebegin" - перед elem</li>
                    <li>"afterbegin" - всередині elem, перед усіма дітьми</li>
                    <li>"beforeend" - всередині elem, після усіх дітей</li>
                    <li>"afterend" - після elem</li>
                </ul>
                <p>
                    "beforebegin" і "afterend" працюють тільки тоді, коли elem вже знаходиться в DOM-дереві.
                </p>

                <pre>
    const list = document.querySelector(".list");
    list.insertAdjacentHTML("beforeend", markup);
    list.insertAdjacentHTML("beforebegin", 
            "&lt;h2&gt;Popular technologies&lt;/h2&gt;");
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Підключення скриптів</h2>
                <p>
                    Завантаження і виконання скрипта, зазначеного в тезі /script/ без будь-яких атрибутів, 
                    блокують обробку HTML-документа і побудову DOM. Це проблема.
                </p>
                <pre>
    &lt;script src="path-to-script.js"&gt;&lt;/script&gt;
                </pre>
                <p>
                    Коли аналізатор зустрічає такий тег, обробка HTML-документа припиняється і починається 
                    завантаження файлу скрипта, зазначеного в атрибуті src. Після завантаження скрипт 
                    виконується, і тільки потім відновлюється обробка HTML. Це називається «блокуючий» скрипт.
                </p>

                <h3>Атрибут defer</h3>
                <pre>
    &lt;script defer src="path-to-script.js"&gt;&lt;/script&gt;
                </pre>
                <p>
                    Атрибут defer вказує браузеру завантажувати файл скрипта у фоновому режимі, паралельно 
                    обробці HTML-документа і побудові DOM. Скрипт буде виконаний тільки після того, як HTML-
                    документ був оброблений, а DOM побудований. Такі скрипти не блокують побудову DOM-дерева
                     і гарантовано виконуються у тому порядку, в якому вказані в HTML-документі.
                </p>

                <h3>Атрибут async</h3>
                <pre>
    &lt;script async src="path-to-script.js"&gt;&lt;/script&gt;
                </pre>
                <p>
                    Завантаження скрипта з атрибутом async не блокує побудову DOM, але він виконується відразу 
                    після завантаження. Це означає, що такі скрипти можуть заблокувати побудову DOM, і 
                    виконуються у довільному порядку.
                </p>

            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Події</h2>
                <p>
                    Існує багато видів подій: миші, клавіатури, елементів форм, завантаження зображень, 
                    буфера обміну, зміни стадії CSS анімації або переходу, зміни розмірів вікна та багато інших.
                </p>
                <p>
                    Одна дія може викликати декілька подій. Наприклад, клік викликає спочатку mousedown, 
                    а потім mouseup і click.
                </p>
                <p>
                    Для того, щоб елемент реагував на дії користувача, до нього необхідно додати слухача (обробника) події. 
                    Тобто функцію, яка буде викликана, щойно подія відбулася.
                </p>

                <h3>Метод addEventListener()</h3>
                <pre>
    element.addEventListener(event, handler, options);
                </pre>
                <ul>
                    <li>event - ім'я події, рядок, наприклад "click".</li>
                    <li>handler - колбек-функція, яка буде викликана під час настання події.</li>
                    <li>options - необов'язковий об'єкт параметрів з розширеними налаштуваннями.</li>
                </ul>
                <pre>
    const button = document.querySelector(".my-button");

    button.addEventListener("click", () => {
      console.log("Button was clicked");
    });

    або
    const handleClick = () => {
        console.log("Button was clicked");
      };
      
      button.addEventListener("click", handleClick);
                </pre>

                <p>
                    На одному елементі може бути будь-яка кількість обробників подій, навіть подій одного типу. 
                    Колбек-функції будуть викликатися у порядку їх реєстрації в коді.
                </p>

                <pre>
    const multiBtn = document.querySelector("#multiple");

    const firstCallback = () => {
      console.log("First callback!");
    };
    const secondCallback = () => {
      console.log("Second callback!");
    };

    multiBtn.addEventListener("click", firstCallback);
    multiBtn.addEventListener("click", secondCallback);
                </pre>
                
                <h3>Метод removeEventListener()</h3>
                <p>
                    Видаляє слухача події з елемента. Аргументи аналогічні методу addEventListener().
                </p>
                <pre>
    element.removeEventListener(event, handler, options);
                </pre>
                <p>
                    Для видалення потрібно передати посилання саме на ту колбек-функцію, яка була призначена 
                    в addEventListener(). У такому разі, для колбеків використовують окрему функцію і 
                    передають її за ім'ям (посиланням).
                </p>

                <h3>Ключове слово this</h3>
                <p>
                    Якщо колбеком буде функція, яка використовує this, за замовчуванням контекст всередині 
                    неї буде посилатися на DOM-елемент, на якому висить слухач.
                </p>

                <pre>
    const mango = {
        username: "Mango",
        showUsername() {
          console.log(this);
          console.log(`My username is: ${this.username}`);
        },
      };
      
      const btn = document.querySelector(".js-btn");
      
      // ✅ Працює
      mango.showUsername();
      
      // ❌ this буде посилатися на button, якщо 
      використовувати showUsername як callback
      btn.addEventListener("click", mango.showUsername); // не працює
      
      // ✅ Не забувайте прив'язувати контекст методів об'єкта
      btn.addEventListener("click", mango.showUsername.bind(mango));
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Об'єкт події</h2>
                <p>
                    Щоб обробити подію - недостатньо знати про те, що це клік або натискання клавіші, 
                    можуть знадобитися деталі. Наприклад, поточне значення текстового поля, елемент, 
                    на якому відбулася подія, вбудовані методи та інші.
                </p>
                <p>
                    Кожна подія - це об'єкт, який містить інформацію про деталі події та автоматично 
                    передається першим аргументом в обробник події. Всі події відбуваються з базового 
                    класу Event
                </p>

                <pre>
    const handleClick = event => {
        console.log(event);
      };
      
      button.addEventListener("click", handleClick);
                </pre>

                <p>
                    Ми можемо називати його як завгодно, але, як правило, його оголошують як e, evt або event.
                </p>

                <p>Деякі властивості об'єкта події:</p>
                <ul>
                    <li>event.type - тип події.</li>
                    <li>event.currentTarget - елемент, на якому виконується обробник події.</li>
                    <li>event.clientX</li>
                    <li>event.clientY</li>
                    <li>event.offsetX</li>
                    <li>event.offsetY</li>
                    <li>event.screenX</li>
                    <li>event.screenY</li>
                </ul>

                <h3>Дії браузера за замовчуванням</h3>
                <h3>Form</h3>
                <p>
                    Для скасування дії браузера за замовчуванням в об'єкта події є стандартний 
                    метод preventDefault().
                </p>

                <pre>
                    const form = document.querySelector(".register-form");

form.addEventListener("submit", (event) => {
  event.preventDefault();
  const {
    elements: { username, password }
  } = event.currentTarget;
  console.log(username.value, password.value);
});
                </pre>

            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Події клавіатури</h2>

                <p>
                    Існує дві основні події клавіатури: keydown і keyup.
                </p>
                <p>
                    На відміну від інших, події клавіатури обробляються на документі, а не на конкретному елементі. 
                    Об'єкти подій клавіатури походять від базового класу KeyboardEvent.
                </p>
                <pre>
    document.addEventListener("keydown", event => {
        console.log("Keydown: ", event);
      });
      
      document.addEventListener("keyup", event => {
        console.log("Keyup: ", event);
      });
                </pre>
                <p>
                    Натискаючи клавішу, спочатку відбувається keydown, після чого - keyup
                </p>
                <p>
                    На практиці переважно обробляють тільки подію keydown, оскільки вона відбувається швидше за keyup
                </p>
                <p>
                    Раніше була ще одна подія клавіатури - keypress. вона застаріла
                </p>

                <h3>Властивості key і code​</h3>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>JS Tests</h2>
            </div>
        </section>



    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
                <p>address</p>
            </address>
        </div>
    </footer>

    <!-- <script src="../../js/dom.js"></script> -->
</body>
</html>