<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS-DOM</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
    <link rel="stylesheet" href="../../css/style-js-btn-top.css">
</head>

<body>
    <header>
        <div>
            <a  class="fixed-back" href="../../index.html">Back to main page</a>
            <nav>
            </nav>
        </div>
    </header>

    <main>
        <!-- Button to top -->
        <button class="toTop">
            <svg class="svgButtonToTop" xmlns="http://www.w3.org/2000/svg" width="32" height="32">
                <path d="M16 1 1 16h9v16h12V16h9z" />
            </svg>
        </button>

        <section class="section-title">
            <div class="container">
                <h1>JS DOM and Event</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Об'єктна модель документа</li>
                    <li>Навігація по DOM</li>
                    <li><a href="#dom-find-elem">Пошук елементів</a></li>
                    <li><a href="#dom-atribute-elem">Властивості та атрибути</a></li>
                    <li>Властивість textContent</li>
                    <li>Властивість classList</li>
                    <li>Властивість style</li>
                    <li>Атрибути</li>
                    <li><a href="#dom-create-elem">Створення та видалення елементів</a></li>
                    <li>Оптимізація роботи з DOM</li>
                    <li><a href="#dom-innerHTML">Властивість innerHTML</a></li>
                    <li>Метод insertAdjacentHTML()</li>
                    <li><a href="#dom-script">Підключення скриптів</a> defer async</li>
                    <li><a href="#events">Події</a> addEventListener() removeEventListener()</li>
                    <li>Ключове слово this</li>
                    <li>Об'єкт події</li>
                    <li>Дії браузера за замовчуванням - preventDefault()</li>
                    <li><a href="#key-event">Події клавіатури</a></li>
                    <li><a href="#form-event">Події елементів форм</a></li>
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Список основних методів</h2>

                <h3>Пошук елемента</h3>
                <ul>
                    <li>= document.querySelector('#menu');</li>
                    <li>= document.querySelector('.menu');</li>
                    <li>= document.querySelectorAll("li");</li>
                    <li>= document.querySelector('button[data-action="text"]');</li>
                </ul>

                <h3>Інлайн стилі</h3>
                <ul>
                    <li>menu.style.textTransform = 'uppercase';</li>
                    <li></li>
                    <li></li>
                </ul>

                <h3>Навігації по ієрархії</h3>
                <ul>
                    <li>elem.parentNode - вибере батьківський elem.</li>
                    <li>elem.childNodes - псевдомасив, зберігає всі дочірні елементи, включно з текстовими.</li>
                    <li>elem.children - псевдомасив, зберігає тільки дочірні вузли-елементи, тобто ті, що відповідають тегам.</li>
                    <li>elem.firstChild - вибере перший дочірній елемент всередині elem, включно з текстовими вузлами.</li>
                    <li>elem.firstElementChild - вибере перший дочірній вузол-елемент всередині elem.</li>
                    <li>elem.lastChild - вибере останній дочірній елемент всередині elem, включно з текстовими вузлами.</li>
                    <li>elem.lastElementChild - вибере останній дочірній вузол-елемент всередині elem.</li>
                    <li>elem.previousSibling - вибере елемент «зліва» від elem (його попереднього сусіда).</li>
                    <li>elem.previousElementSibling - вибере вузол-елемент «зліва» від elem (його попереднього сусіда).</li>
                    <li>elem.nextSibling - вибере елемент «праворуч» від elem (його наступного сусіда)</li>
                    <li>elem.nextElementSibling - вибере вузол-елемент «праворуч» від elem (його наступного сусіда).</li>
                </ul>

                <h3>Маніпуляції з класами</h3>
                <ul>
                    <li>elem.classList.contains(cls) - повертає true або false</li>
                    <li>elem.classList.add(cls)</li>
                    <li>elem.classList.remove(cls)</li>
                    <li>elem.classList.toggle(cls)</li>
                    <li>elem.classList.replace(oldClass, newClass)</li>
                </ul>

                <h3>Маніпуляції з атрибутами</h3>
                <ul>
                    <li>elem.hasAttribute(name)</li>
                    <li>elem.getAttribute(name)</li>
                    <li>elem.removeAttribute(name)</li>
                    <li>elem.attributes - об'єкт</li>
                    <li>elem.disabled=false;</li>
                    <li>elem.dataset.action // data-action="save"</li>
                </ul>

                <h3>Створення Видалення</h3>
                <ul>
                    <li>document.createElement(tagName);</li>
                    <li>element.append(el1, el2, ...) - після всіх дітей елемента</li>
                    <li>element.prepend(el1, el2, ...) - перед усіма дітьми елемента</li>
                    <li>element.after(el1, el2, ...) - після елемента element</li>
                    <li>element.before(el1, el2, ...) - перед елемента element</li>
                    <li>elem.remove();</li>
                </ul>

                
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Об'єктна модель документа</h2>
                <p>
                    Об'єктна модель документа (Document Object Model) - незалежний від мови інтерфейс для роботи 
                    з HTML-документом. Містить набір властивостей і методів, що дозволяють шукати, створювати 
                    і видаляти елементи, реагувати на дії користувача і багато іншого. Тобто з'єднує сторінку 
                    з мовою програмування.
                </p>
                <p>
                    DOM - це відображення HTML-документа, деревоподібна структура, в якій кожен вузол - 
                    це JavaScript-об'єкт з властивостями і методами, що становить частину HTML-документа. 
                    Кожен елемент в документі, весь документ в цілому, заголовок, посилання, абзац - 
                    це частини DOM цього документа, тому всі вони можуть бути змінені з JavaScript-коду.
                </p>
                <p>
                    Об'єктна модель браузера (Browser Object Model) - незалежний від мови інтерфейс для 
                    роботи з вкладкою браузера. Містить набір властивостей і методів, що дозволяють отримати 
                    доступ безпосередньо до поточної вкладки і ряду функцій браузера. Містить об'єкт роботи з 
                    історією навігації, місцем розташування та багато іншого.
                </p>
                <div>
                    <img src="../../img/js-dom.jpg" alt="js-dom.img" width="400">
                </div>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Навігація по DOM</h2>
                <p>
                    document - це частина глобального об'єкта window, який доступний у скрипті, 
                    коли він виконується в браузері. Так само як alert, console.log, prompt і багато інших.
                </p>
                <p>
                    Найвищий елемент називається кореневим (root node).
                </p>
                <p>
                    Для навігації по цій ієрархії елементи мають наступні властивості:
                </p>
                <ul>
                    <li>elem.parentNode - вибере батьківський elem.</li>
                    <li>elem.childNodes - псевдомасив, зберігає всі дочірні елементи, включно з текстовими.</li>
                    <li>elem.children - псевдомасив, зберігає тільки дочірні вузли-елементи, тобто ті, що відповідають тегам.</li>
                    <li>elem.firstChild - вибере перший дочірній елемент всередині elem, включно з текстовими вузлами.</li>
                    <li>elem.firstElementChild - вибере перший дочірній вузол-елемент всередині elem.</li>
                    <li>elem.lastChild - вибере останній дочірній елемент всередині elem, включно з текстовими вузлами.</li>
                    <li>elem.lastElementChild - вибере останній дочірній вузол-елемент всередині elem.</li>
                    <li>elem.previousSibling - вибере елемент «зліва» від elem (його попереднього сусіда).</li>
                    <li>elem.previousElementSibling - вибере вузол-елемент «зліва» від elem (його попереднього сусіда).</li>
                    <li>elem.nextSibling - вибере елемент «праворуч» від elem (його наступного сусіда)</li>
                    <li>elem.nextElementSibling - вибере вузол-елемент «праворуч» від elem (його наступного сусіда).</li>
                </ul>
                <p>
                    Приклад <a href="https://codepen.io/goit-academy/pen/oNZqxoP" target="_blank">codepen.</a>
                    <a href="../js-page.html#example-1" target="_blank">Example 1</a>
                </p>

                <pre>
    &lt;ul class="list"&gt;
        &lt;li&gt;First item&lt;/li&gt;
        &lt;li&gt;Second item&lt;/li&gt;
        &lt;li&gt;Third item&lt;/li&gt;
        &lt;li&gt;Fourth item&lt;/li&gt;
        &lt;li&gt;Fifth item&lt;/li&gt;
    &lt;/ul&gt;</pre>
                

                <pre>
    console.log(document);

    const body = document.body;
    console.log(body);

    const list = document.querySelector(".list");
    console.log(list);

    const firstListItem = list.firstElementChild;
    console.log(firstListItem);

    const lastListItem = list.lastElementChild;
    console.log(lastListItem);

    const listItems = list.children;
    console.log(listItems);</pre>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2 id="dom-find-elem">Пошук елементів</h2>
                <p>
                    Отже, ми вже знаємо що DOM-елемент - це об'єкт з властивостями і методами. 
                    Саме час навчитися швидко знаходити елемент за довільним CSS-селектором. 
                    Група методів elem.querySelector* - це сучасний стандарт для пошуку елементів. 
                    Вони дозволяють знайти елемент або групу елементів за CSS-селектором будь-якої складності.
                </p>
                <code>element.querySelector(selector);</code>
                <ul>
                    <li>
                        Використовується, якщо необхідно знайти тільки один, найчастіше унікальний елемент.
                    </li>
                    <li>
                        Повертає перший знайдений елемент всередині element, що відповідає CSS-селектору selector.
                    </li>
                    <li>
                        Якщо нічого не знайдено, поверне null.
                    </li>
                </ul>

                <code>element.querySelectorAll(selector);</code>
                <ul>
                    <li>
                        Використовується, якщо необхідно знайти колекцію елементів, тобто отримати масив 
                        посилань на елементи з однаковим селектором. Наприклад, всі елементи списку з класом 
                        menu-item
                    </li>
                    <li>
                        Повертає псевдомасив всіх елементів всередині element, які відповідають CSS-селектору selector.
                    </li>
                    <li>
                        Якщо нічого не знайдено, поверне порожній масив.
                    </li>
                </ul>

                <p>Приклад <a href="https://codepen.io/goit-academy/pen/wvJmGbG" target="_blank">codepen</a></p>
                <pre>
    &lt;ul id="menu" class="menu"&gt;
        &lt;li class="menu-item"&gt;home&lt;/li&gt;
        &lt;li class="menu-item"&gt;about&lt;/li&gt;
        &lt;li class="menu-item"&gt;gallery&lt;/li&gt;
        &lt;li&gt;blog&lt;/li&gt;
    &lt;/ul&gt;</pre>
                

                <pre>
    const listWithId = document.querySelector('#menu');
    listWithId.style.textTransform = 'uppercase';
    listWithId.style.fontSize = '24px';
    console.log(listWithId);

    const listWithClass = document.querySelector('.menu');
    console.log(listWithClass);

    const menuItemsByTagName = document.querySelectorAll("li");
    console.log(menuItemsByTagName);

    const menuItemsByClass = document.querySelectorAll(".menu-item");
    console.log(menuItemsByClass);

    const firstMenuItem = document.querySelector(".menu-item");
    firstMenuItem.style.color = 'tomato';
    console.log(firstMenuItem);</pre>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2 id="dom-atribute-elem">Властивості та атрибути</h2>
                <p>
                    Під час побудови DOM-дерева, деякі стандартні HTML-атрибути стають властивостями 
                    елементів. Подивимося на декілька властивостей, які часто використовуються.
                </p>
                <ul>
                    <li>value - містить поточний текстовий контент елементів форм</li>
                    <li>checked - зберігає стан чекбокса або радіокнопки.</li>
                    <li>name - зберігає значення, вказане в HTML-атрибуті name.</li>
                    <li>src - шлях до зображення тегу img.</li>
                </ul>
                <pre>
    &lt;img class="image" 
        src="https://picsum.photos/id/9/320/240" 
        alt="A laptop" 
        width="300" /&gt;</pre>
                
                <div>
                    <img class="image" src="https://picsum.photos/id/9/320/240" 
                        alt="A laptop" 
                        width="300" />
                </div>
                <pre>
    const image = document.querySelector(".image");
    console.log(image.src); // https://picsum.photos/id/9/320/240
    console.log(image.alt); // A laptop

    image.src = "https://picsum.photos/id/13/640/480";
    image.alt = "River bank";</pre>
    <p>(item.dataset.color = color)  === (data-color="#7E0D44")</p>
                

                <h3>Властивість textContent</h3>
                <p><a href="../js-page.html#example-2" target="_blank">Example-2</a></p>
                <p>
                    <b>elem.textContent</b> повертає текстовий контент всередині елемента. Доступний для читання
                     і запису. Неважливо, що буде передано в textContent, дані завжди будуть записані 
                     як текст.
                </p>
                <pre>
    const titleEl = document.querySelector(".article-title");
    titleEl.textContent = 'Welcome to Bahamas!';</pre>


                <h3>Властивість classList</h3>
                <p>
                    У властивості classList зберігається об'єкт з методами для роботи з класами елемента.
                </p>
                <ul>
                    <li>
                        elem.classList.contains(cls) - повертає true або false, залежно від наявності 
                        класу cls в елемента.
                    </li>
                    <li>elem.classList.add(cls) - додає клас cls до списку класів елемента.</li>
                    <li>elem.classList.remove(cls) - видаляє клас cls зі списку класів елемента.</li>
                    <li>
                        elem.classList.toggle(cls) - якщо відсутній клас cls, то додає його, 
                        якщо - присутній, навпаки - видаляє.
                    </li>
                    <li>
                        elem.classList.replace(oldClass, newClass) - замінює існуючий клас 
                        oldClass на вказаний newClass.
                    </li>
                </ul>
               
                <pre>
    HTML
    &lt;a class="link is-active" href=""&gt;A random link&lt;/a&gt;

    JS
    const link = document.querySelector(".link");
    console.log(link.classList);

    const hasActiveClass = link.classList.contains("is-active");
    console.log(`hasActiveClass - ${hasActiveClass}`);

    link.classList.add("special");
    console.log(link.classList);

    link.classList.remove("is-active");
    console.log(link.classList);

    link.classList.toggle("is-active");
    console.log(link.classList);

    link.classList.replace("special", "regular");
    console.log(link.classList);</pre>
                

                <h3>Властивість style​</h3>
                <p>
                    Використовується для читання та зміни інлайнових стилів. Повертає об'єкт 
                    CSSStyleDeclaration, який містить список усіх властивостей, визначених тільки 
                    у вбудованих стилях елемента, а не увесь CSS. Під час запису властивості записуються 
                    в camelCase, тобто background-color перетворюється на element.style.backgroundColor тощо.
                </p>
                <pre>
    const button = document.querySelector(".btn");

    button.style.backgroundColor = "teal";
    button.style.fontSize = "24px";
    button.style.textAlign = "center";
    arrowSecond.style = "transform: rotate(60deg)"; 
    arrowSecond.style.transform = "rotate(45deg)";</pre>
                
                <p>
                    На практиці стилізація елементів виконується шляхом додавання CSS-класів. 
                    Властивість style використовується для додавання будь-яких динамічних стилів, 
                    наприклад, під час анімації.
                </p>

                <h3>Атрибути</h3>
                <p>
                    Доступ до атрибутів здійснюється за допомогою стандартних методів. Ці методи працюють 
                    зі значенням, яке знаходиться в HTML.
                </p>
                <ul>
                    <li>
                        elem.hasAttribute(name) - перевіряє наявність атрибута, повертає true або false.
                    </li>
                    <li>elem.getAttribute(name) - отримує значення атрибута і повертає його.</li>
                    <li>elem.setAttribute(name, value) - встановлює атрибут.</li>
                    <li>elem.removeAttribute(name) - видаляє атрибут.</li>
                    <li>elem.attributes - властивість, що повертає об'єкт усіх атрибутів елемента.</li>
                </ul>
                <pre>
    const image = document.querySelector(".image");

    console.log(image.attributes); 
            // NamedNodeMap {0: class, 1: src, 2: alt, length: 3}
    console.log(image.hasAttribute("src")); // true
    console.log(image.getAttribute("alt")); // "Rocks and waterfall"
    image.setAttribute("alt", "Amazing nature");
    console.log(image.getAttribute("alt")); // Amazing</pre>
                

                <h3>data-атрибути</h3>
                <p>
                    Дозволяють додати до тегу довільний атрибут і отримати його значення в JavaScript. 
                    Цю можливість використовують для того, щоб спростити написання коду, наприклад, 
                    зв'язати дані і розмітку за унікальним ідентифікатором, вказати тип дії кнопки тощо
                </p>
                <p>
                    Для отримання значення data-атрибута використовується властивість dataset, 
                    після якого стоїть ім'я атрибута. Тобто data- відкидається, а інша частина імені 
                    записується як ім'я властивості об'єкта.
                </p>
                <pre>
    &lt;button type="button" data-action="save"&gt;Save&lt;/button&gt;

    const saveBtn = document.querySelector('button[data-action="save"]');
    console.log(saveBtn.dataset.action); // "save"</pre>
               
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2 id="dom-create-elem">Створення та видалення елементів</h2>
                <p>
                    DOM API дозволяє не тільки вибирати або змінювати вже існуючі, але й видаляти, 
                    а також створювати нові елементи, після чого додавати їх в документ.
                </p>

                <h3>Створення</h3>
                <pre>
    document.createElement(tagName);</pre>
                
                <p>Елемент створюється в пам'яті, в DOM його ще немає.</p>
                <h3>Додавання</h3>
                <p>
                    Щоб створений елемент відображався на сторінці, його необхідно додати до 
                    вже існуючого елемента в DOM-дереві.
                </p>
                <p>для цього існують методи:</p>
                <ul>
                    <li>
                        element.append(el1, el2, ...) - додає один або декілька елементів 
                        після всіх дітей елемента element.
                    </li>
                    <li>
                        element.prepend(el1, el2, ...) - додає один або декілька елементів 
                        перед усіма дітьми елемента element.
                    </li>
                    <li>
                        element.after(el1, el2, ...) - додає один або декілька елементів після елемента element.
                    </li>
                    <li>
                        element.before(el1, el2, ...) - додає один або декілька елементів перед елементом element.
                    </li>
                </ul>
               
                <pre>
    &lt;h1&gt;Usernames&lt;/h1&gt;
    &lt;ul class="usernames"&gt;
        &lt;li&gt;Mango&lt;/li&gt;
    &lt;/ul&gt;

    const list = document.querySelector(".usernames");

    const item = document.createElement("li");
    item.textContent = "Poly";
    list.append(item);</pre>
                
                <h2>Перевірити!!!!</h2>
                <p>
                    Якщо елемент для додавання вже знаходиться в DOM, то він видаляється зі свого старого 
                    місця і додається у нове. З цього випливає правило - один і той самий елемент не може 
                    бути одночасно у двох місцях.
                </p>

                <h3>Видалення</h3>
                <pre>
    elem.remove();</pre>
                
                <p>
                    Для того, щоб видалити елемент, використовується метод remove(). 
                    Він викликається на елементі elem, який необхідно видалити.
                </p>
                <h4>Example</h4>
                <pre>
    &lt;p class="text"&gt;Text&lt;/p&gt;

    const text = document.querySelector('.text');
    text.remove();</pre>
                

                <h3>Оптимізація роботи з DOM</h3>
                <p>
                    зміна DOM-дерева - це дорога операція, тому 
                    необхідно намагатися мінімізувати кількість звернень до DOM.
                </p>
                <p>
                    Repaint - відбувається, коли зміни торкнулися стилів, 
                    що впливають на зовнішній вигляд елемента, але не на геометрію.
                </p>
                <p>
                    Reflow - відбувається, коли зміни впливають на вміст, структуру документу, положення елементів. 
                    Відбувається перерахунок позиціонування і розмірів, що призводить до повторного створення 
                    частини або всього документу.
                </p>
                <p>
                    Сторінка не може виконувати жодні інші операції у той час, коли відбувається reflow або repaint.
                </p>
                <p>Причинами можуть бути:</p>
                <ul>
                    <li>Маніпуляції з DOM (додавання, видалення, зміна, перестановка елементів)</li>
                    <li>Зміна вмісту, зокрема тексту в полях форм</li>
                    <li>Розрахунок або зміна CSS-властивостей</li>
                    <li>Додавання і видалення таблиць стилів</li>
                    <li>Маніпуляції з атрибутом class</li>
                    <li>Маніпуляції з вікном браузера (зміни розмірів, прокручування)</li>
                    <li>Активація псевдокласів (наприклад, ':hover')</li>
                </ul>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2 id="dom-innerHTML">Властивість innerHTML</h2>
                <p>
                    Ще один спосіб створити DOM-елементи і помістити їх в дерево - це використовувати рядки з 
                    тегами і дозволити браузеру зробити всю важку роботу. У такого підходу є свої плюси і мінуси.
                </p>
                <h3>Читання</h3>
                <p>
                    Властивість innerHTML зберігає вміст елемента, включно з тегами, у вигляді рядка. Значення, 
                    що повертається, - це завжди валідний HTML-код.
                </p>
                <pre>
    const article = document.querySelector(".article");
    console.log(article.innerHTML);</pre>
                

                <h3>Зміна</h3>
                <p>
                    Властивість innerHTML доступна і для читання, і для запису. Якщо записати в неї рядок з 
                    HTML-тегами, то браузер під час парсингу рядка перетворить їх у валідні елементи і 
                    додасть в DOM-дерево.
                </p>
                <pre>
    const title = document.querySelector(".article .title");
    title.innerHTML = 'New and &lt;span class="accent"&gt;improved&lt;/span&gt; title';</pre>
                

                <p>
                    Якщо у властивість innerHTML записати порожній рядок, то вміст елемента буде очищено. 
                    Це простий і швидкий спосіб видалення всього вмісту.
                </p>
                <p>
                    Однотипна (шаблонна) розмітка створюється із масиву даних. Прийом полягає у перебиранні 
                    цього масиву і складанні одного рядка з HTML-тегами, який потім записуємо в innerHTML 
                    елемента.
                </p>
                <p><a href="../js-page.html#example-5" target="_blank">Example-5</a></p>
                <pre>
    &lt;ul class="list"&gt;&lt;/ul&gt;

    const technologies = ["HTML", "CSS", "JS", "React", "Node"];
    const list = document.querySelector(".list");

    const markup = technologies
    .map((technology) => `&lt;li class="list-item"&gt;${technology}&lt;/li&gt;`)
    .join("");

    list.innerHTML = markup;</pre>
               

                <h3>Додавання</h3>
                <p>
                    Зміна elem.innerHTML повністю видалить і повторно створить всі нащадки елемента elem. 
                    Якщо елемент спочатку не був порожній, то виникнуть додаткові витрати на серіалізацію 
                    вже існуючої розмітки, а це погано.
                </p>
                <p>
                    Використовуйте властивість elem.innerHTML для додавання тільки тоді, коли елемент elem - 
                    порожній, або якщо потрібно повністю замінити його вміст.
                </p>

                <h3>Метод insertAdjacentHTML()</h3>
                <p>
                    Сучасний метод для додавання рядка з HTML-тегами перед, після або всередину елемента. Вирішує проблему innerHTML з повторною серіалізацією вмісту елемента під час додавання розмітки до вже існуючої.
                </p>
                <pre>
    elem.insertAdjacentHTML(position, string);
                </pre>
                <p>
                    Аргумент position - це рядок, позиція щодо елемента elem. Приймає одне з чотирьох значень
                </p>
                <ul>
                    <li>"beforebegin" - перед elem</li>
                    <li>"afterbegin" - всередині elem, перед усіма дітьми</li>
                    <li>"beforeend" - всередині elem, після усіх дітей</li>
                    <li>"afterend" - після elem</li>
                </ul>
                <p>
                    "beforebegin" і "afterend" працюють тільки тоді, коли elem вже знаходиться в DOM-дереві.
                </p>
                <p><a href="../js-page.html#example-6" target="_blank">Example-6</a></p>
                <pre>
    const list = document.querySelector(".list");
    list.insertAdjacentHTML("beforeend", markup);
    list.insertAdjacentHTML("beforebegin", 
            "&lt;h2&gt;Popular technologies&lt;/h2&gt;");</pre>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2 id="dom-script">Підключення скриптів</h2>
                <p>
                    Завантаження і виконання скрипта, зазначеного в тезі /script/ без будь-яких атрибутів, 
                    блокують обробку HTML-документа і побудову DOM. Це проблема.
                </p>
                <pre>
    &lt;script src="path-to-script.js"&gt;&lt;/script&gt;</pre>
                
                <p>
                    Коли аналізатор зустрічає такий тег, обробка HTML-документа припиняється і починається 
                    завантаження файлу скрипта, зазначеного в атрибуті src. Після завантаження скрипт 
                    виконується, і тільки потім відновлюється обробка HTML. Це називається «блокуючий» скрипт.
                </p>

                <h3>Атрибут defer</h3>
                <pre>
    &lt;script defer src="path-to-script.js"&gt;&lt;/script&gt;</pre>
                
                <p>
                    Атрибут defer вказує браузеру завантажувати файл скрипта у фоновому режимі, паралельно 
                    обробці HTML-документа і побудові DOM. Скрипт буде виконаний тільки після того, як HTML-
                    документ був оброблений, а DOM побудований. Такі скрипти не блокують побудову DOM-дерева
                     і гарантовано виконуються у тому порядку, в якому вказані в HTML-документі.
                </p>

                <h3>Атрибут async</h3>
                <pre>
    &lt;script async src="path-to-script.js"&gt;&lt;/script&gt;</pre>
                
                <p>
                    Завантаження скрипта з атрибутом async не блокує побудову DOM, але він виконується відразу 
                    після завантаження. Це означає, що такі скрипти можуть заблокувати побудову DOM, і 
                    виконуються у довільному порядку.
                </p>

            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2 id="events">Події</h2>
                <p>
                    Існує багато видів подій: миші, клавіатури, елементів форм, завантаження зображень, 
                    буфера обміну, зміни стадії CSS анімації або переходу, зміни розмірів вікна та багато інших.
                </p>
                <p>
                    Одна дія може викликати декілька подій. Наприклад, клік викликає спочатку mousedown, 
                    а потім mouseup і click.
                </p>
                <p>
                    Для того, щоб елемент реагував на дії користувача, до нього необхідно додати слухача (обробника) події. 
                    Тобто функцію, яка буде викликана, щойно подія відбулася.
                </p>

                <h3>Метод addEventListener()</h3>
                <pre>
    element.addEventListener(event, handler, options);</pre>
                
                <ul>
                    <li>event - ім'я події, рядок, наприклад "click".</li>
                    <li>handler - колбек-функція, яка буде викликана під час настання події.</li>
                    <li>options - необов'язковий об'єкт параметрів з розширеними налаштуваннями.</li>
                </ul>
                <pre>
    const button = document.querySelector(".my-button");

    button.addEventListener("click", () => {
      console.log("Button was clicked");
    });

    або
    const handleClick = () => {
        console.log("Button was clicked");
      };
      
      button.addEventListener("click", handleClick); </pre>
               

                <p>
                    На одному елементі може бути будь-яка кількість обробників подій, навіть подій одного типу. 
                    Колбек-функції будуть викликатися у порядку їх реєстрації в коді.
                </p>

                <pre>
    const multiBtn = document.querySelector("#multiple");

    const firstCallback = () => {
      console.log("First callback!");
    };
    const secondCallback = () => {
      console.log("Second callback!");
    };

    multiBtn.addEventListener("click", firstCallback);
    multiBtn.addEventListener("click", secondCallback);</pre>
                
                
                <h3>Метод removeEventListener()</h3>

                <p>
                    Видаляє слухача події з елемента. Аргументи аналогічні методу addEventListener().
                </p>
                <pre>
    element.removeEventListener(event, handler, options);</pre>
                
                <p>
                    Для видалення потрібно передати посилання саме на ту колбек-функцію, яка була призначена 
                    в addEventListener(). У такому разі, для колбеків використовують окрему функцію і 
                    передають її за ім'ям (посиланням).
                </p>

                <h3>Ключове слово this</h3>
                <p>
                    Якщо колбеком буде функція, яка використовує this, за замовчуванням контекст всередині 
                    неї буде посилатися на DOM-елемент, на якому висить слухач.
                </p>

                <pre>
    const mango = {
        username: "Mango",
        showUsername() {
          console.log(this);
          console.log(`My username is: ${this.username}`);
        },
      };
      
      const btn = document.querySelector(".js-btn");
      
      // ✅ Працює
      mango.showUsername();
      
      // ❌ this буде посилатися на button, якщо 
      використовувати showUsername як callback
      btn.addEventListener("click", mango.showUsername); // не працює
      
      // ✅ Не забувайте прив'язувати контекст методів об'єкта
      btn.addEventListener("click", mango.showUsername.bind(mango)); </pre>
               
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Об'єкт події</h2>
                <p>
                    Щоб обробити подію - недостатньо знати про те, що це клік або натискання клавіші, 
                    можуть знадобитися деталі. Наприклад, поточне значення текстового поля, елемент, 
                    на якому відбулася подія, вбудовані методи та інші.
                </p>
                <p>
                    Кожна подія - це об'єкт, який містить інформацію про деталі події та автоматично 
                    передається першим аргументом в обробник події. Всі події відбуваються з базового 
                    класу Event
                </p>

                <pre>
    const handleClick = event => {
        console.log(event);
      };
      
      button.addEventListener("click", handleClick);</pre>
                

                <p>
                    Ми можемо називати його як завгодно, але, як правило, його оголошують як e, evt або event.
                </p>

                <p>Деякі властивості об'єкта події:</p>
                <ul>
                    <li>event.type - тип події.</li>
                    <li>event.currentTarget - елемент, на якому виконується обробник події.</li>
                    <li>event.clientX</li>
                    <li>event.clientY</li>
                    <li>event.offsetX</li>
                    <li>event.offsetY</li>
                    <li>event.screenX</li>
                    <li>event.screenY</li>
                </ul>

                <h3>Дії браузера за замовчуванням</h3>
                <h3>Form</h3>
                <p>
                    Для скасування дії браузера за замовчуванням в об'єкта події є стандартний 
                    метод preventDefault().
                </p>

                <pre>
    const form = document.querySelector(".register-form");

    form.addEventListener("submit", (event) => {
      event.preventDefault();
      const {
        elements: { username, password }
      } = event.currentTarget;
      console.log(username.value, password.value);
    });</pre>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2 id="key-event">Події клавіатури</h2>

                <p>
                    Існує дві основні події клавіатури: keydown і keyup.
                </p>
                <p>
                    На відміну від інших, події клавіатури обробляються на документі, а не на конкретному елементі. 
                    Об'єкти подій клавіатури походять від базового класу KeyboardEvent.
                </p>
                <pre>
    document.addEventListener("keydown", event => {
        console.log("Keydown: ", event);
      });
      
      document.addEventListener("keyup", event => {
        console.log("Keyup: ", event);
      });</pre>
                
                <p>
                    Натискаючи клавішу, спочатку відбувається keydown, після чого - keyup
                </p>
                <p>
                    На практиці переважно обробляють тільки подію keydown, оскільки вона відбувається швидше за keyup
                </p>
                <p>
                    Раніше була ще одна подія клавіатури - keypress. вона застаріла
                </p>

                <h3>Властивості key і code​</h3>
                <p>
                    key повертає символ, згенерований натисканням клавіші, враховуючи стан клавіш-модифікаторів, наприклад, Shift, а також поточну мову.
                </p>
                <p>
                    Властивість code повертає код фізичної клавіші на клавіатурі і не залежить від мови.
                </p>
                <pre>
    <a href="https://codepen.io/goit-academy/pen/ZEeRxaJ"target="_blank">codepen</a>
    document.addEventListener("keydown", event => {
        console.log("key: ", event.key);
        console.log("code: ", event.code);
      });</pre>

                <pre>
    document.addEventListener("keydown", logMessage);
    document.addEventListener("keyup", logMessage);

    function logMessage({ type, key, code }) {
      const markup = `&lt;div class="log-item"&gt;
     &lt;span class="chip"&gt;${keypressCounter}&lt;/span&gt;
       &lt;ul&gt;
           &lt;li&gt;Event: ${type}&lt;/li&gt;
           &lt;li&gt;Key: ${key}&lt;/li&gt;
           &lt;li&gt;Code: ${code}&lt;/li&gt;
       &lt;/ul&gt;
       &lt;/div&gt;`;

    logList.insertAdjacentHTML("afterbegin", markup);
    }</pre>
                

                <h3>Клавіші-модифікатори</h3>
                <p>
                    Для обробки комбінації клавіш, наприклад Ctrl + s або будь-якої іншої, 
                    на об'єкті події є властивості ctrlKey, altKey, shiftkey і metaKey, 
                    що зберігають булеве значення, яке сигналізує про те, чи була затиснута 
                    клавіша-модифікатор.
                </p>

                <pre>
    document.addEventListener("keydown", event => {
        event.preventDefault();
      
        if ((event.ctrlKey || event.metaKey) && event.code === "KeyS") {
          console.log("«Ctrl + s» or «Command + s» combo");
        }
      });</pre>
                

                <p>
                    Деякі комбінації клавіш можуть конфліктувати з поведінкою браузера за замовчуванням. 
                    Наприклад, Ctrl + d або Command + d робить закладку. Потрібно намагатися проектувати 
                    систему комбінацій сторінки таким чином, щоб вона не перетиналася із вбудованою у 
                    браузері. Але, у крайньому разі, поведінку за замовчуванням можна скасувати, 
                    викликавши метод event.preventDefault().
                </p>
                <p>властивість keyCode - застаріла</p>
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2 id="form-event">Форми. Події елементів форм</h2>
                <h3>Подія submit​</h3>
                <p>
                    Відправлення форми відбувається під час кліку по кнопці з атрибутом type="submit" 
                    або натискання клавіші Enter, перебуваючи в будь-якому її текстовому полі.
                </p>
                <p>
                    Сабміт форми перезавантажує сторінку, тому не забувайте скасовувати дію за 
                    замовчуванням методом preventDefault().
                </p>

                <pre>
    <a href="https://codepen.io/goit-academy/pen/oNZydVL" target="_blank">codepen</a>                
    const registerForm = document.querySelector(".form");

    registerForm.addEventListener("submit", handleSubmit);

    function handleSubmit(event) {
      event.preventDefault();
      const form = event.target;
      const login = form.elements.login.value;
      const password = form.elements.password.value;
    
      if (login === "" || password === "") {
        return console.log("Please fill in all the fields!");
      }

      console.log(`Login: ${login}, Password: ${password}`);
      form.reset();
    }</pre>
                
                <p>
                    Властивість elements DOM-елемента форми містить об'єкт з посиланнями на усі її 
                    елементи, які мають атрибут name. Тому в прикладі ми отримуємо значення полів, 
                    звертаючись до login.value і password.value.
                </p>

                <h3>Подія change</h3>
                <p>
                    Відбувається після зміни елемента форми. Для текстових полів або textarea подія 
                    відбудеться не на кожному введенні символу, а після втрати фокусу, що не завжди зручно. 
                    Наприклад, доки ви набираєте щось у текстовому полі - подія відсутня, але як тільки 
                    фокус пропав, відбудеться подія change. Для інших елементів, наприклад, select, 
                    чекбоксів і радіо-кнопок, подія change спрацьовує відразу під час вибору значення.
                </p>
     
                <pre>
    <a href="https://codepen.io/goit-academy/pen/gOmKKvj" target="_blank">codepen</a> 
    HTML
    &lt;p&gt;
        Selected option text: &lt;span class="text-output"&gt;none&lt;/span&gt;
    &lt;p&gt;
    &lt;p&gt;
        Selected option value: &lt;span class="value-output"&gt;none&lt;/span&gt;
    &lt;p&gt;

  &lt;select class="pizza-select"&gt;
    &lt;option value="four_meats"&gt;Four Meats&lt;/option&gt;
    &lt;option value="royal_cheese"&gt;Royal Cheese&lt;/option&gt;
    &lt;option value="vegetarian"&gt;Vegetarian&lt;/option&gt;
    &lt;option value="smoked_salmon"&gt;Smoked Salmon&lt;/option&gt;
  &lt;/select&gt;
                
    const select = document.querySelector(".pizza-select");
    const textOutput = document.querySelector(".text-output");
    const valueOutput = document.querySelector(".value-output");

    select.addEventListener("change", setOutput);

    function setOutput(event) {
      const selectedOptionValue = event.currentTarget.value;
      const selectedOptionIndex = event.currentTarget.selectedIndex;
      const selectedOptionText =
        event.currentTarget.options[selectedOptionIndex].text;

      textOutput.textContent = selectedOptionText;
      valueOutput.textContent = selectedOptionValue;
    }</pre>
                

                <h3>Подія input​</h3>
                <p>
                    Відбувається тільки на текстових полях і textarea, і створюється щоразу при зміні 
                    значення елемента, не чекаючи втрати фокусу. 
                    На практиці input - це найголовніша подія для роботи з текстовими полями форми.
                </p>

                <pre>
    <a href="https://codepen.io/goit-academy/pen/jOBKpNP" target="_blank">codepen</a>  
    HTML
    &lt;input type="text" class="text-input" /&gt;
    &lt;p&gt;Text field value: &lt;span class="output"&gt;&lt;/span&gt;&lt;/p&gt;

    JS
    const textInput = document.querySelector(".text-input");
    const output = document.querySelector(".output");

    textInput.addEventListener("input", (event) => {
    output.textContent = event.currentTarget.value;
    });</pre>
                

                <h3>Подія focus і blur</h3>

                <p>
                    Елемент отримує фокус під час кліку миші або переходу клавішею Tab. Момент отримання 
                    і втрати фокусу - дуже важливий, отримуючи фокус, ми можемо завантажити дані для 
                    автозаповнення, почати відстежувати зміни тощо. Під час втрати фокусу - перевірити 
                    введені дані.
                </p>
                <p>
                    Під час фокусування елемента відбувається подія focus, а коли фокус зникає, наприклад, 
                    користувач клікає в іншому місці екрана, відбувається подія blur.
                </p>
                <p>
                    Активувати або скасувати фокус можна програмно, викликавши в коді для елемента 
                    однойменні методи focus() і blur().
                </p>
             
                <pre>
    <a href="https://codepen.io/goit-academy/pen/JjWZBdM" target="_blank">codepen</a>
    const textInput = document.querySelector(".text-input");
    const setFocusBtn = document.querySelector('[data-action="set"]');
    const removeFocusBtn = document.querySelector('[data-action="remove"]');

    setFocusBtn.addEventListener("click", () => {
      textInput.focus();
    });

    removeFocusBtn.addEventListener("click", () => {
      textInput.blur();
    });

    textInput.addEventListener("focus", () => {
      textInput.value = "This input has focus";
    });

    textInput.addEventListener("blur", () => {
      textInput.value = "";
    });</pre>
                

                <p>
                    Фокус може бути тільки на одному елементі сторінки за одиницю часу, і поточний елемент, 
                    на якому знаходиться фокус, доступний як document.activeElement.
                </p>

            </div>
        </section>



    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
                <p>address</p>
            </address>
        </div>
    </footer>

    <script src="../../js-exampl/btn-top.js"></script>
</body>
</html>