<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS arraw</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
</head>

<body>
    <header>
        <div>
            <a  class="fixed-back" href="../../index.html">Back to main page</a>
            <nav>
            </nav>
        </div>
    </header>

    <main>
        <section class="section-title">
            <div class="container">
                <h1>JS масиви</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Збірка методів масиву</li>
                    <li>Збірка перебираючих методів масиву</li>
                    <li>Створення масиву</li>
                    <li>Ітерація по масиву</li>
                    <li>Оператори <code>break і continue</code> ​</li>
                    <li>Методи масиву детально</li>
                    <li>Деструктуризація масивів</li>
                    <li>Перебираючі методи масиву детально</li>
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Збірка методів масиву</h2>
                <ul>
                    <li><code>array.length</code></li>
                    <li><code>for (const variable of iterable)</code></li>
                    <li><code>array.split(""); // ["M", "a", "n", "g", "o"]</code> "Mango"</li>
                    <li><code>array.join(" "); // "це цікаво"</code> "це", "цікаво"</li>
                    <li><code>array.indexOf("Poly"); // 2</code></li>
                    <li><code>array.includes("Poly"); // true</code></li>
                    <li><code>array.push(3); // [1, 2, 3]</code></li>
                    <li><code>array.pop(); // [1, 2]</code> 3 remove</li>
                    <li><code>array.slice(1, 3); // ["Ajax", "Poly"]</code></li>
                    <li><code>scores.splice(0, 3);</code></li>
                    <li><code>const allClients = oldClients.concat(newClients);</code></li>         
                </ul>

                <h2>Збірка перебираючих методів масиву</h2>
                <ul>
                    <li>Метод arr.forEach(callback)</li>
                    <li>Метод arr.map(callback)</li>
                    <li>Метод arr.flatMap(callback)</li>
                    <li>Метод arr.filter(callback)</li>
                    <li>Метод arr.find(callback)</li>
                    <li>Метод arr.findIndex(callback)</li>
                    <li></li>
                    <li></li>
                </ul>
                
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h3>Створення масиву</h3>
                <ul>
                    <li><code>const clients = ["Mango", "Poly", "Ajax"];</code></li>
                    <li><code>console.log(clients[0]); // Mango</code></li>
                    <li><code>array.length</code></li> 
                </ul>
                <h3>Ітерація по масиву</h3>
    <h4>for</h4>
    <pre>
        <code> for (let i = 0; i &lt; clients.length; i += 1) {
        console.log(clients[i]);
        }</code>
    </pre>

    <h4>for...of break | continue</h4>
    <pre>
        <code> 
        const clients = ["Mango", "Ajax", "Poly"];
        for (const client of clients) { // Але без доступу до лічильника
            console.log(client);
        }

        for (const client of clients) {
            if (client === clientNameToFind) {
                message = "Клієнт з таким ім'ям є в базі даних!";
                break;
            }
        }
        for (let i = 0; i &lt; numbers.length; i += 1) {
            if (numbers[i] &lt; threshold) {
                continue;
            }
            console.log(`Число більше за ${threshold}: ${numbers[i]}`);
        }
        </code>
    </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Методи масиву детально</h2>
                <ul>
                    <li><code>name.split(""); // ["M", "a", "n", "g", "o"]</code> "Mango"</li>
                    <li><code>message.split(" "); // ["це", "цікаво"]</code>"це цікаво"</li>
                    <li><code>words.join(" "); // "це цікаво"</code> "це", "цікаво"</li>
                    <li><code>words.join(""); // "цецікаво"</code> "це", "цікаво"</li>
                    <li><code>const clients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                    <li><code>console.log(clients.indexOf("Poly")); // 2</code></li>
                    <li><code>console.log(clients.indexOf("Monkong")); // -1</code></li>
                    <li><code>console.log(clients.includes("Poly")); // true</code></li>
                    <li><code>array.push(3); // [1, 2, 3]</code>додає на кінці масиву</li>
                    <li><code>array.pop(); // [1, 2]</code> 3 remove</li>
                    <li>
                        <h4>slice(begin, end) - повертає копію частини вихідного масиву</h4>
                        <ul>
                            <li><code>const clients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                            <li><code>console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]</code></li>
                            <li>Якщо begin і end не зазначені, буде створена повна копія вихідного масиву</li>
                            <li>Якщо не зазначено end, копіювання буде зі start і до кінця вихідного масиву</li>
                            <li>Якщо значення start від'ємне, а end не зазначено - будуть скопійовані останні start елементи</li>
                            <li><code>const clients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                            <li><code>console.log(clients.slice(-2)); // ["Poly", "Kiwi"]</code></li>
                        </ul>
                    </li>
                    
                    <li>
                        <h4>splice(pos, num) - </h4>
                        <ul>
                            <li> змінює вихідний масив і повертає масив, що містить видалені елементи.</li>
                            <li><code>const scores = [1, 2, 3, 4, 5];</code></li>
                            <li><code>const deletedScores = scores.splice(0, 3);</code></li>
                            <li><code>console.log(scores); // [4, 5]</code></li>
                            <li><code>console.log(deletedScores); // [1, 2, 3]</code></li>
                            <li><h4>splice Додавання</h4></li>
                            <li><code>splice(position, 0, new_element_1, new_element_2, ...)</code></li>
                            <li>position вказує початкову позицію в масиві, куди будуть вставлені нові елементи.</li>
                            <li>нуль, він говорить методу не видаляти елементи в місці додавання нових.</li>
                            <li>Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.</li>
                            <li><code>const colors = ["red", "green", "blue"];</code></li>
                            <li><code>colors.splice(2, 0, "purple");</code></li>
                            <li><code>console.log(colors); // ["red", "green", "purple", "blue"]</code></li>
                            <li><h4>splice Заміна - видаляються елементи в місці додавання нових</h4></li>
                            <li><code>splice(position, num, new_element_1, new_element_2, ...)</code></li>
                            <li>position - вказує на позицію (індекс) першого елемента для видалення</li>
                            <li>num - визначає кількість елементів, що видаляються</li>
                            <li>Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.</li>
                            <li>
                                <pre>
                                    <code>
    const languages = ["C", "C++", "Java", "JavaScript"];
    languages.splice(1, 1, "Python");
    console.log(languages); // ["C", "Python", "Java", "JavaScript"]
    languages.splice(2, 1, "C#", "Swift", "Go");
    console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]
                                    </code>
                                </pre>
                            </li>
                            <li></li>
                            <li></li>
                        </ul>
                    </li>

                    <li>
                        <h4>concat() - Об'єднує два або більше масивів в один. повертає новий</h4>
                        <ul>
                            <li><code>const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                            <li><code>const newClients = ["Monkong", "Singu"];</code></li>
                            <li><code>const allClients = oldClients.concat(newClients);</code></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>Деструктуризація масивів</h2>
                <p>
                    Наприклад, є масив кольорів, з якого потрібно отримати значення кожної складової кольору в окремих змінних
                </p>
                <pre>
                    const rgb = [200, 255, 100];
                    const [red, green, blue] = rgb;
                    console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"
                    const [red, green, blue, alfa = 0.3] = rgb;
                </pre>
                <p>
                    Іноді з масиву необхідно деструктуризувати тільки перші N елементів, а інші зберегти в одну змінну у вигляді масиву. 
                    Деструктуруючи масив, можна розпакувати і присвоїти іншу частину елементів масиву змінної, використовуючи операцію ... (rest).
                </p>
                <pre>
                    const rgb = [200, 255, 100];
                    const [red, ...colors] = rgb;
                </pre>
                <p>
                    Елементи можна пропускати. Припустимо, з масиву rgb необхідно взяти тільки останнє значення. На практиці ця можливість рідко використовується.
                </p>
                <pre>
                    const rgb = [200, 100, 255];
                    const [, , blue] = rgb;
                    console.log(`Blue: ${blue}`); // "Blue: 255"
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Перебираючі методи масиву детально</h2>
                <h3>Метод arr.forEach(callback)</h3>
                <p>
                    Метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією даних.
                </p>
                <pre>
                    const numbers = [5, 10, 15, 20, 25];

                    // Класичний for
                    for (let i = 0; i / numbers.length; i += 1) {
                        console.log(`Індекс ${i}, значення ${numbers[i]}`);
                    }

                    // Метод перебирання forEach
                    numbers.forEach(function (number, index) {
                        console.log(`Індекс ${index}, значення ${number}`);
                    });
                </pre>
                <ul>
                    <li>Поелементно перебирає масив.</li>
                    <li>Викликає колбек-функцію для кожного елемента масиву.</li>
                    <li>Нічого не повертає.</li>
                    <li>Можна оголошувати тільки необхідні параметри, найчастіше - це елемент</li>
                    <li>головне не забувати про їх порядок.</li>
                    <li>Перервати виконання методу forEach не можна, він завжди перебирає масив до кінця.</li>
                </ul>
                <p>
                    В JavaScript є методи масивів, що прийшли з функціональних мов. Більшість з них - це чисті функції. 
                </p>
                <pre>
                    array.method((item, idx, arr) => {
                        // логіка, яка буде застосовуватися на кожній ітерації
                      });
                </pre>
                <p>
                    Всі параметри, крім значення елемента item, - необов'язкові. Назви параметрів можуть бути будь-які, 
                    але є неофіційні домовленості
                </p>

                <h3>Метод arr.map(callback)</h3>
                <pre>
                    массив.map((element, index, array) => {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод map(callback) використовується для трансформації масиву. Він викликає колбек-функцію для 
                    кожного елемента вихідного масиву, а результат її роботи записує у новий масив, який і буде 
                    результатом виконання методу.
                </p>
                <pre>
                const students = [
                    { name: "Манго", score: 83 },
                    { name: "Полі", score: 59 },
                    { name: "Аякс", score: 37 },
                    { name: "Ківі", score: 94 },
                    { name: "Х'юстон", score: 64 },
                ];

                const names = students.map(student => student.name);
                console.log(names); // ['Манго', 'Полі', 'Аякс', 'Ківі', 'Х'юстон']
                </pre>

                <h3>Метод arr.flatMap(callback)</h3>
                <pre>
                    массив.flatMap((element, index, array) => {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    аналогічний методу map(), але застосовується у випадках, коли результат - 
                    це багатовимірний масив, який необхідно «розгладити».
                </p>
                <p>
                    У масиві students зберігається список студентів зі списком предметів, які відвідує студент, 
                    у властивості courses. Кілька студентів можуть відвідувати один і той самий предмет. 
                    Необхідно скласти список всіх предметів, які відвідує ця група студентів, поки що, 
                    навіть повторюваних.
                </p>
                <pre>
                    const students = [
                        { name: "Ivan", courses: ["математика", "фізика"] },
                        { name: "Kolya", courses: ["інформатика", "математика"] },
                        { name: "Katya", courses: ["фізика", "біологія"] },
                    ];
                    students.map(student => student.courses);
                    // [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']]

                    students.flatMap(student => student.courses);
                    // ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];
                </pre>

                <h3>Метод arr.filter(callback)</h3>
                <pre>
                    масив.filter((element, index, array) => {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод filter використовується для - фільтрації масиву, тобто, коли необхідно вибрати 
                    більше одного елемента з колекції за певним критерієм.
                </p>
                <ul>
                    <li>Не змінює оригінальний масив</li>
                    <li>Повертає новий масив.</li>
                    <li>Додає у масив, що повертається, елементи, які задовольняють умови</li>
                    <li>Якщо жоден елемент не задовольнив умову, повертає порожній масив.</li>
                </ul>
                <pre>
                    const values = [51, -3, 27, 21, -68, 42, -37];

                    const positiveValues = values.filter(value => value >= 0);
                    console.log(positiveValues); // [51, 27, 21, 42]
                </pre>

                <h4>Фільтрація унікальних елементів</h4>
                <p>
                    Цей прийом працює тільки з масивом примітивних значень - не об'єктів.
                </p>
                <pre>
                    const courses = ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];

                    const uniqueCourses = allCourses.filter(
                        (course, index, array) => array.indexOf(course) === index
                    );
                </pre>

                <h4>Фільтрація масиву об'єктів</h4>
                <p>
                    Під час роботи з масивом об'єктів виконується фільтрація за значенням певної властивості. 
                    У підсумку, утворюється новий масив відфільтрованих об'єктів.
                </p>
                <pre>
                const LOW_SCORE = 50;
                const HIGH_SCORE = 80;
                const students = [
                    { name: "Манго", score: 83 },
                    { name: "Полі", score: 59 },
                    { name: "Аякс", score: 37 },
                    { name: "Ківі", score: 94 },
                    { name: "Х'юстон", score: 64 },
                ];

                const best = students.filter(student => student.score >= HIGH_SCORE);
                console.log(best); // Масив об'єктів з іменами Манго і Ківі
                </pre>

                <h3>Метод arr.find(callback)</h3>
                <pre>
                    масив.find((element, index, array) => {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод find(callback) дозволяє знайти і повернути перший відповідний елемент, 
                    після чого перебирання масиву припиняється. Не змінює оригінальний масив.
                    Якщо жоден елемент не задовольнив умову, метод повертає <b>undefined</b>
                </p>
               
                <pre>
                    const colorPickerOptions = [
                        { label: "red", color: "#F44336" },
                        { label: "green", color: "#4CAF50" },
                        { label: "blue", color: "#2196F3" },
                    ];

                    colorPickerOptions.find(option => option.label === "blue"); // { label: 'blue', color: '#2196F3' }
                </pre>

                <h3>Метод arr.findIndex(callback)</h3>
                <pre>
                    масив.findIndex((element, index, array) => {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод findIndex(callback) - це сучасна заміна методу indexOf(). Дозволяє виконувати пошук за складнішими умовами, 
                    ніж просто рівність. Використовується як для пошуку у масиві примітивів, так і в масиві об'єктів.
                </p>
                <ul>
                    <li>Не змінює оригінальний масив.</li>
                    <li>Повертає індекс першого елемента, що задовольняє умову</li>
                    <li>Якщо жоден елемент не задовольняє умову, метод повертає -1.</li>
                </ul>


            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2></h2>
                <ul>
                       
                </ul>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2></h2>
                <ul>
                       
                </ul>
            </div>
        </section>

    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
                <p>address</p>
            </address>
        </div>
    </footer>

    <script src="../../js/array.js"></script>
</body>
</html>