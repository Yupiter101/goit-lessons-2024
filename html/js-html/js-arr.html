<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS arraw</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
</head>

<body>
    <header>
        <div>
            <a  class="fixed-back" href="../../index.html">Back to main page</a>
            <nav>
            </nav>
        </div>
    </header>

    <main>
        <section class="section-title">
            <div class="container">
                <h1>JS масиви</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Збірка методів масиву</li>
                    <li>Збірка перебираючих методів масиву</li>
                    <li>Створення масиву</li>
                    <li>Ітерація по масиву</li>
                    <li>Оператори <code>break і continue</code> ​</li>
                    <li>Методи масиву детально</li>
                    <li>Деструктуризація масивів</li>
                    <li>Перебираючі методи масиву детально</li>
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Збірка методів масиву</h2>
                <ul>
                    <li><code>array.length</code></li>
                    <li><code>for (const variable of iterable)</code></li>
                    <li><code>array.split(""); // ["M", "a", "n", "g", "o"]</code> "Mango"</li>
                    <li><code>array.join(" "); // "це цікаво"</code> "це", "цікаво"</li>
                    <li><code>array.indexOf("Poly"); // 2</code></li>
                    <li><code>array.includes("Poly"); // true</code></li>
                    <li><code>array.push(3); // [1, 2, 3]</code></li>
                    <li><code>array.pop(); // [1, 2]</code> 3 remove</li>
                    <li><code>array.slice(1, 3); // ["Ajax", "Poly"]</code></li>
                    <li><code>scores.splice(0, 3);</code></li>
                    <li><code>const allClients = oldClients.concat(newClients);</code></li>         
                </ul>

                <h2>Збірка перебираючих методів масиву</h2>
                <ul>
                    <li>Метод <code>arr.forEach(callback)</code></li>
                    <li>Метод <code>arr.map(callback)</code></li>
                    <li>Метод <code>arr.flatMap(callback)</code></li>
                    <li>Метод <code>arr.filter(callback)</code></li>
                    <li>Метод <code>arr.find(callback)</code></li>
                    <li>Метод <code>arr.findIndex(callback)</code></li>
                    <li>Метод <code>arr.every(callback)</code></li>
                    <li>Метод <code>arr.some(callback)</code></li>
                    <li>Метод <code>arr.reduce(callback)</code></li>
                    <li>Метод <code>arr.sort(callback)</code></li>
                </ul>
                
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h3>Створення масиву</h3>
                <ul>
                    <li><code>const clients = ["Mango", "Poly", "Ajax"];</code></li>
                    <li><code>console.log(clients[0]); // Mango</code></li>
                    <li><code>array.length</code></li> 
                </ul>
                <h3>Ітерація по масиву</h3>
    <h4>for</h4>
    <pre>
        <code> for (let i = 0; i &lt; clients.length; i += 1) {
        console.log(clients[i]);
        }</code>
    </pre>

    <h4>for...of break | continue</h4>
    <pre>
        <code> 
        const clients = ["Mango", "Ajax", "Poly"];
        for (const client of clients) { // Але без доступу до лічильника
            console.log(client);
        }

        for (const client of clients) {
            if (client === clientNameToFind) {
                message = "Клієнт з таким ім'ям є в базі даних!";
                break;
            }
        }
        for (let i = 0; i &lt; numbers.length; i += 1) {
            if (numbers[i] &lt; threshold) {
                continue;
            }
            console.log(`Число більше за ${threshold}: ${numbers[i]}`);
        }
        </code>
    </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Методи масиву детально</h2>
                <ul>
                    <li><code>name.split(""); // ["M", "a", "n", "g", "o"]</code> "Mango"</li>
                    <li><code>message.split(" "); // ["це", "цікаво"]</code>"це цікаво"</li>
                    <li><code>words.join(" "); // "це цікаво"</code> "це", "цікаво"</li>
                    <li><code>words.join(""); // "цецікаво"</code> "це", "цікаво"</li>
                    <li><code>const clients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                    <li><code>console.log(clients.indexOf("Poly")); // 2</code></li>
                    <li><code>console.log(clients.indexOf("Monkong")); // -1</code></li>
                    <li><code>console.log(clients.includes("Poly")); // true</code></li>
                    <li><code>array.push(3); // [1, 2, 3]</code>додає на кінці масиву</li>
                    <li><code>array.pop(); // [1, 2]</code> 3 remove</li>
                    <li>
                        <h4>slice(begin, end) - повертає копію частини вихідного масиву</h4>
                        <ul>
                            <li><code>const clients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                            <li><code>console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]</code></li>
                            <li>Якщо begin і end не зазначені, буде створена повна копія вихідного масиву</li>
                            <li>Якщо не зазначено end, копіювання буде зі start і до кінця вихідного масиву</li>
                            <li>Якщо значення start від'ємне, а end не зазначено - будуть скопійовані останні start елементи</li>
                            <li><code>const clients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                            <li><code>console.log(clients.slice(-2)); // ["Poly", "Kiwi"]</code></li>
                        </ul>
                    </li>
                    
                    <li>
                        <h4>splice(pos, num) - </h4>
                        <ul>
                            <li> змінює вихідний масив і повертає масив, що містить видалені елементи.</li>
                            <li><code>const scores = [1, 2, 3, 4, 5];</code></li>
                            <li><code>const deletedScores = scores.splice(0, 3);</code></li>
                            <li><code>console.log(scores); // [4, 5]</code></li>
                            <li><code>console.log(deletedScores); // [1, 2, 3]</code></li>
                            <li><h4>splice Додавання</h4></li>
                            <li><code>splice(position, 0, new_element_1, new_element_2, ...)</code></li>
                            <li>position вказує початкову позицію в масиві, куди будуть вставлені нові елементи.</li>
                            <li>нуль, він говорить методу не видаляти елементи в місці додавання нових.</li>
                            <li>Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.</li>
                            <li><code>const colors = ["red", "green", "blue"];</code></li>
                            <li><code>colors.splice(2, 0, "purple");</code></li>
                            <li><code>console.log(colors); // ["red", "green", "purple", "blue"]</code></li>
                            <li><h4>splice Заміна - видаляються елементи в місці додавання нових</h4></li>
                            <li><code>splice(position, num, new_element_1, new_element_2, ...)</code></li>
                            <li>position - вказує на позицію (індекс) першого елемента для видалення</li>
                            <li>num - визначає кількість елементів, що видаляються</li>
                            <li>Третій, четвертий і всі наступні аргументи - це нові елементи, які додаються в масив.</li>
                            <li>
                                <pre>
                                    <code>
    const languages = ["C", "C++", "Java", "JavaScript"];
    languages.splice(1, 1, "Python");
    console.log(languages); // ["C", "Python", "Java", "JavaScript"]
    languages.splice(2, 1, "C#", "Swift", "Go");
    console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]
                                    </code>
                                </pre>
                            </li>
                            <li></li>
                            <li></li>
                        </ul>
                    </li>

                    <li>
                        <h4>concat() - Об'єднує два або більше масивів в один. повертає новий</h4>
                        <ul>
                            <li><code>const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];</code></li>
                            <li><code>const newClients = ["Monkong", "Singu"];</code></li>
                            <li><code>const allClients = oldClients.concat(newClients);</code></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>



        <section class="section-about">
            <div class="container">
                <h2>Деструктуризація масивів</h2>
                <p>
                    Наприклад, є масив кольорів, з якого потрібно отримати значення кожної складової кольору в окремих змінних
                </p>
                <pre>
                    const rgb = [200, 255, 100];
                    const [red, green, blue] = rgb;
                    console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"
                    const [red, green, blue, alfa = 0.3] = rgb;
                </pre>
                <p>
                    Іноді з масиву необхідно деструктуризувати тільки перші N елементів, а інші зберегти в одну змінну у вигляді масиву. 
                    Деструктуруючи масив, можна розпакувати і присвоїти іншу частину елементів масиву змінної, використовуючи операцію ... (rest).
                </p>
                <pre>
                    const rgb = [200, 255, 100];
                    const [red, ...colors] = rgb;
                </pre>
                <p>
                    Елементи можна пропускати. Припустимо, з масиву rgb необхідно взяти тільки останнє значення. На практиці ця можливість рідко використовується.
                </p>
                <pre>
                    const rgb = [200, 100, 255];
                    const [, , blue] = rgb;
                    console.log(`Blue: ${blue}`); // "Blue: 255"
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Перебираючі методи масиву детально</h2>
                <h3>Метод arr.forEach(callback)</h3>
                <p>
                    Метод перебирання масиву, який використовується для заміни циклів for і for...of в 
                    роботі з колекцією даних.
                </p>
                <pre>
                    const numbers = [5, 10, 15, 20, 25];

                    // Класичний for
                    for (let i = 0; i / numbers.length; i += 1) {
                        console.log(`Індекс ${i}, значення ${numbers[i]}`);
                    }

                    // Метод перебирання forEach
                    numbers.forEach(function (number, index) {
                        console.log(`Індекс ${index}, значення ${number}`);
                        arr[index] = number * 2;
                    });
                </pre>
                <ul>
                    <li>Поелементно перебирає масив.</li>
                    <li>Викликає колбек-функцію для кожного елемента масиву.</li>
                    <li>Нічого не повертає.</li>
                    <li>index and arr не обовязкові</li>
                    <li>Можна оголошувати тільки необхідні параметри, найчастіше - це елемент</li>
                    <li>головне не забувати про їх порядок.</li>
                    <li>Перервати виконання методу forEach не можна, він завжди перебирає масив до кінця.</li>
                    <li>Немає return</li>
                    <li>Мутує масив</li>
                </ul>
                <p>
                    В JavaScript є методи масивів, що прийшли з функціональних мов. Більшість з них - це чисті функції. 
                </p>
                <pre>
                    array.method((item, idx, arr) =&gt; {
                        // логіка, яка буде застосовуватися на кожній ітерації
                      });
                </pre>
                <p>
                    Всі параметри, крім значення елемента item, - необов'язкові. Назви параметрів можуть бути будь-які, 
                    але є неофіційні домовленості
                </p>

                <h3>Метод arr.map(callback)</h3>
                <pre>
                    массив.map((element, index, array) =&gt; {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод map(callback) використовується для трансформації масиву. Він викликає колбек-функцію для 
                    кожного елемента вихідного масиву, а результат її роботи записує у новий масив, який і буде 
                    результатом виконання методу.
                </p>
                <pre>
                const students = [
                    { name: "Манго", score: 83 },
                    { name: "Полі", score: 59 },
                    { name: "Аякс", score: 37 },
                    { name: "Ківі", score: 94 },
                    { name: "Х'юстон", score: 64 },
                ];

                const names = students.map(student =&gt; student.name);
                console.log(names); // ['Манго', 'Полі', 'Аякс', 'Ківі', 'Х'юстон']
                </pre>

                <h3>Метод arr.flatMap(callback)</h3>
                <pre>
                    массив.flatMap((element, index, array) =&gt; {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    аналогічний методу map(), але застосовується у випадках, коли результат - 
                    це багатовимірний масив, який необхідно «розгладити».
                </p>
                <p>
                    У масиві students зберігається список студентів зі списком предметів, які відвідує студент, 
                    у властивості courses. Кілька студентів можуть відвідувати один і той самий предмет. 
                    Необхідно скласти список всіх предметів, які відвідує ця група студентів, поки що, 
                    навіть повторюваних.
                </p>
                <pre>
                    const students = [
                        { name: "Ivan", courses: ["математика", "фізика"] },
                        { name: "Kolya", courses: ["інформатика", "математика"] },
                        { name: "Katya", courses: ["фізика", "біологія"] },
                    ];
                    students.map(student =&gt; student.courses);
                    // [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']]

                    students.flatMap(student =&gt; student.courses);
                    // ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];
                </pre>

                <h3>Метод arr.filter(callback)</h3>
                <pre>
                    масив.filter((element, index, array) => {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод filter використовується для - фільтрації масиву, тобто, коли необхідно вибрати 
                    більше одного елемента з колекції за певним критерієм.
                </p>
                <ul>
                    <li>Не змінює оригінальний масив</li>
                    <li>Повертає новий масив.</li>
                    <li>Додає у масив, що повертається, елементи, які задовольняють умови</li>
                    <li>Якщо жоден елемент не задовольнив умову, повертає порожній масив.</li>
                </ul>
                <pre>
                    const values = [51, -3, 27, 21, -68, 42, -37];

                    const positiveValues = values.filter(value => value >= 0);
                    console.log(positiveValues); // [51, 27, 21, 42]
                </pre>

                <h4>Фільтрація унікальних елементів</h4>
                <p>
                    Цей прийом працює тільки з масивом примітивних значень - не об'єктів.
                </p>
                <pre>
                    const courses = ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];

                    const uniqueCourses = allCourses.filter(
                        (course, index, array) =&gt; array.indexOf(course) === index
                    );
                </pre>

                <h4>Фільтрація масиву об'єктів</h4>
                <p>
                    Під час роботи з масивом об'єктів виконується фільтрація за значенням певної властивості. 
                    У підсумку, утворюється новий масив відфільтрованих об'єктів.
                </p>
                <pre>
                const LOW_SCORE = 50;
                const HIGH_SCORE = 80;
                const students = [
                    { name: "Манго", score: 83 },
                    { name: "Полі", score: 59 },
                    { name: "Аякс", score: 37 },
                    { name: "Ківі", score: 94 },
                    { name: "Х'юстон", score: 64 },
                ];

                const best = students.filter(student =&gt; student.score &gt;= HIGH_SCORE);
                console.log(best); // Масив об'єктів з іменами Манго і Ківі
                </pre>

                <h3>Метод arr.find(callback)</h3>
                <pre>
                    масив.find((element, index, array) =&gt; {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод find(callback) дозволяє знайти і повернути перший відповідний елемент, 
                    після чого перебирання масиву припиняється. Не змінює оригінальний масив.
                    Якщо жоден елемент не задовольнив умову, метод повертає <b>undefined</b>
                </p>
               
                <pre>
                    const colorPickerOptions = [
                        { label: "red", color: "#F44336" },
                        { label: "green", color: "#4CAF50" },
                        { label: "blue", color: "#2196F3" },
                    ];

                    colorPickerOptions.find(option =&gt; option.label === "blue"); // { label: 'blue', color: '#2196F3' }
                </pre>

                <h3>Метод arr.findIndex(callback)</h3>
                <pre>
                    масив.findIndex((element, index, array) =&gt; {
                        // Тіло колбек-функції
                      });
                </pre>
                <p>
                    Метод findIndex(callback) - це сучасна заміна методу indexOf(). Дозволяє виконувати пошук за складнішими умовами, 
                    ніж просто рівність. Використовується як для пошуку у масиві примітивів, так і в масиві об'єктів.
                </p>
                <ul>
                    <li>Не змінює оригінальний масив.</li>
                    <li>Повертає індекс першого елемента, що задовольняє умову</li>
                    <li>Якщо жоден елемент не задовольняє умову, метод повертає -1.</li>
                </ul>

                <h3>Метод arr.every(callback)</h3>
                <p>
                    Перевіряє, чи проходять всі елементи масиву тест колбек-функції. 
                    Повертає true або false
                </p>
                <pre>
                    масив.every((element, index, array) =&gt; {
                        // Тіло колбек-функції
                      });
                </pre>
                <ul>
                    <li>Не змінює оригінальний масив.</li>
                    <li>Повертає true, якщо всі елементи масиву задовольняють умову</li>
                    <li>Повертає false, якщо хоча б один елемент масиву не задовольняє умову</li>
                    <li>Перебирання масиву припиняється, якщо колбек повертає false</li>
                </ul>
                <pre>
                    [1, 2, 3, 4, 5].every(value =&gt; value &gt;= 0); // true
                    [1, 2, 3, -10, 4, 5].every(value =&gt; value &gt;= 0); // false
                </pre>

                <h3>Метод arr.some(callback)</h3>
                <p>
                    Перевіряє, чи проходить хоча б один елемент масиву тест колбек-функції. 
                    Повертає true або false
                </p>
                <pre>
                    масив.some((element, index, array) =&gt; {
                        // Тіло колбек-функції
                      });
                </pre>
                <ul>
                    <li>Не змінює оригінальний масив.</li>
                    <li>Повертає true, якщо хоча б один елемент масиву задовольняє умову.</li>
                    <li>Повертає false, якщо жоден елемент масиву не задовольняє умову</li>
                    <li>Перебирання масиву припиняється, якщо колбек повертає true</li>
                </ul>
                <pre>
                    [1, 2, 3, 4, 5].some(value =&gt; value &gt;= 0); // true
                    [1, 2, 3, 4, 5].some(value =&gt; value &lt; 0); // false

                    const fruits = [
                        { name: "apples", amount: 100 },
                        { name: "bananas", amount: 0 },
                        { name: "grapes", amount: 50 },
                    ];

                    const allAvailable = fruits.every(fruit =&gt; fruit.amount &gt; 0); // false
                    const anyAvailable = fruits.some(fruits =&gt; fruits.amount &gt; 0); // true
                </pre>

                <h3>Метод arr.reduce(callback)</h3>
                <pre>
                    масив.reduce((previousValue, element, index, array) =&gt; {
                        // Тіло колбек-функції
                      }, initialValue);
                </pre>
                <p>
                    Метод reduce(callback, initialValue) використовується для послідовної обробки кожного 
                    елемента масиву із збереженням проміжного результату, як акумулятор.
                </p>
                <ul>
                    <li>Не змінює оригінальний масив.</li>
                    <li>Повертає все, що завгодно.</li>
                    <li>Робить все, що завгодно.</li>
                </ul>
                <h4>прикладі підрахунку суми елементів масиву</h4>
                <pre>
                    const total = [2, 7, 3, 14, 6].reduce((previousValue, number) =&gt; {
                        return previousValue + number;
                      }, 0);
                      
                      console.log(total); // 32
                </pre>
                <p>
                    Другим аргументом для reduce() можна передати необов'язкове початкове значення акумулятора - 
                    параметр initialValue.
                </p>

                <h4>Задача 1. Необхідно отримати середній бал</h4>
                <pre>
                    const students_4 = [
                        { name: "Манго", score: 83 },
                        { name: "Полі", score: 59 },
                        { name: "Аякс", score: 60 },
                    ];

                    const totalScore = students_4.reduce((acum, student)=&gt; {
                        return acum + student.score;
                    }, 0);

                    const averScore = totalScore / students_4.length;
                </pre>

                <h4>Задача 2.</h4>
                <p>
                    з масиву постів твіттера окремого користувача необхідно порахувати суму усіх лайків
                </p>
                <pre>
                const tweets = [
                    { id: "000", likes: 5, tags: ["js", "nodejs"] },
                    { id: "001", likes: 2, tags: ["html", "css"] },
                    { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
                    { id: "003", likes: 8, tags: ["css", "react"] },
                    { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
                ];
                const likes = tweets.reduce((totalLikes, tweet) =&gt; totalLikes + tweet.likes, 0);
                //напишемо функцію
                const countLikes = tweets => {
                    return tweets.reduce((totalLikes, tweet) =&gt; totalLikes + tweet.likes, 0);
                };
                console.log(countLikes(tweets)); // 32
                </pre>

                <h4>Задача 3.</h4>
                <p>зберемо в масив усі теги, які зустрічаються в постах.</p>
                <pre>
                    const tags = tweets.reduce((allTags, tweet) =&gt; {
                        allTags.push(...tweet.tags); 
                          
                        return allTags;
                      }, []);
                      
                      console.log(tags);

                    // напишемо функцію
                    const getTags = tweets =>
                      tweets.reduce((allTags, tweet) =&gt; {
                        allTags.push(...tweet.tags);

                        return allTags;
                      }, []);
                    
                    console.log(getTags(tweets));
                </pre>
                <h4>порахувати кількість унікальних тегів в масиві.</h4>
                <pre>
                    const getTags = tweets =&gt;
                    tweets.reduce((allTags, tweet) =&gt; {
                        allTags.push(...tweet.tags);

                        return allTags;
                    }, []);

                    const tags = getTags(tweets);

                    // Винесемо callback-функцію окремо, а в reducе передамо посилання на неї.
                    // Це стандартна практика, якщо callback-функція досить велика.

                    // Якщо в об'єкті-акумуляторі acc відсутня своя властивість з ключем tag,
                    // то створюємо її і записуємо їй значення 0.
                    // В іншому випадку збільшуємо значення на 1.
                    const getTagStats = (acc, tag) =&gt; {
                        if (!acc.hasOwnProperty(tag)) {
                            acc[tag] = 0;
                        }

                        acc[tag] += 1;

                        return acc;
                    };

                    // Початкове значення акумулятора - це порожній об'єкт {}
                    const countTags = tags =&gt; tags.reduce(getTagStats, {});

                    const tagCount = countTags(tags);
                    console.log(tagCount);
                </pre>

                <h3>Метод arr.sort(callback)</h3>
                <ul>
                    <li>Сортує і змінює вихідний масив.</li>
                    <li>Повертає змінений масив,</li>
                    <li>За замовчуванням сортує за зростанням.</li>
                    <li>Сортування відбувається шляхом приведення значень до рядка і порівняння порядкових номерів у таблиці Unicode.</li>
                    <li>стандартне сортування чисел працює незвично</li>
                </ul>
                <pre>
                    const scores = [27, 2, 41, 4, 7, 3, 75];
                    scores.sort();
                    console.log(scores); // [2, 27, 3, 4, 41, 7, 75]
                </pre>
                <p>
                    Масив рядків сортується за алфавітом.
                </p>
                <pre>
            const students = ["Віка", "Андрій", "Олег", "Юля", "Борис", "Катя"];
            students.sort();
            console.log(students); // [ 'Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля' ]
                </pre>
                <p>Водночас порядковий номер великих літер менший, ніж у малих.</p>
                <pre>
                const letters = ["b", "B", "a", "A", "c", "C"];
                letters.sort();
                console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']
                </pre>

                <p>
                    Через те, що сортується вихідний масив, порушується принцип чистоти функцій і не можна 
                    зручно створити декілька похідних колекцій на основі вихідної. Наприклад, створити 
                    колекцію, відсортовану за зростанням, а іншу - за спаданням. Тому перед сортуванням 
                    роблять повну копію вихідного масиву і сортують вже її.
                </p>
                <pre>
                const scores = [61, 19, 74, 35, 92, 56];
                const ascendingScores = [...scores].sort();

                console.log(scores); // [61, 19, 74, 35, 92, 56]
                console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]
                </pre>

                <h4>Свій порядок сортування чисел</h4>
                <pre>
                    массив.sort((a, b) =&gt; {
                        // Тіло колбек-функції
                      });
                      a - перший елемент для порівняння.
                      b - другий елемент для порівняння.
                </pre>
                <p>
                    Якщо виклик compareFunction(a, b) повертає будь-яке від'ємне значення, тобто a менше b, сортування поставить a перед b. 
                    Це сортування за зростанням.
                </p>

                <pre>
                    const scores = [61, 19, 74, 35, 92, 56];
                    const ascendingScores = [...scores].sort((a, b) => a - b);
                    console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]
                </pre>

                <p>
                    Якщо виклик compareFunction(a, b) повертає будь-яке додатне значення більше нуля, тобто b більше a, сортування поставить b перед a. 
                    Це сортування за спаданням.
                </p>
                <pre>
                    const scores = [61, 19, 74, 35, 92, 56];
                    const descendingScores = [...scores].sort((a, b) => b - a);
                    console.log(descendingScores); // [92, 74, 61, 56, 35, 19]
                </pre>

                <h4>Свій порядок сортування рядків</h4>
                <p>
                    Для сортування рядків в алфавітному порядку, за зростанням або спаданням, використовується метод рядків localeCompare().
                </p>
                <pre>
                    firstString.localeCompare(secondString)
                </pre>
                <p>
                    Він викликається на рядку, який потрібно порівняти (firstString) з тим, що був переданий йому як аргумент (secondString).
                </p>
                <pre>
                    "a".localeCompare("b"); // -1
                    "b".localeCompare("a"); // 1
                    "a".localeCompare("a"); // 0
                    "b".localeCompare("b"); // 0
                </pre>
                <pre>
            const students = ["Віка", "Андрій", "Олег", "Юля", "Борис", "Катя"];

            const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
            console.log(inAlphabetOrder); // ['Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля']

            const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
            console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Віка', 'Борис', 'Андрій']
                </pre>

                <h4>Сортування об'єктів</h4>

                <p>
                    Під час роботи з масивом об'єктів, сортування виконується за числовим або рядковим значенням певної властивості. 
                    Наприклад, у нас є група студентів з балами за тест. Необхідно відсортувати масив об'єктів за зростанням і 
                    спаданням кількості балів, і за ім'ям студента.
                </p>
                <pre>
            const students = [
                { name: "Манго", score: 83 },
                { name: "Полі", score: 59 },
                { name: "Аякс", score: 37 },
                { name: "Ківі", score: 94 },
            ];

            const inAscendingScoreOrder = students.sort(
                (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
            );

            const inDescendingScoreOrder = students.sort(
                (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
            );

            const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
                firstStudent.name.localeCompare(secondStudent.name)
            );
                </pre>

                <h3>Ланцюжки методів</h3>
                <pre>
                const names = [...students]
                .sort((a, b) => a.score - b.score)
                .map(student => student.name);

                console.log(names); // ['Аякс', 'Полі', 'Манго', 'Ківі']
                </pre>
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2></h2>
                <ul>
                       
                </ul>
            </div>
        </section>



    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
                <p>address</p>
            </address>
        </div>
    </footer>

    <script src="../../js/array.js"></script>
</body>
</html>