<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
</head>

<body>
    <header>
        <div>
            <a  class="fixed-back" href="../../index.html">Back to main page</a>
            <nav>
            </nav>
        </div>
    </header>

    <main>
        <section class="section-title">
            <div class="container">
                <h1>JS Функції</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Оголошення функції</li>
                    <li>Параметри за замовчуванням</li>
                    <li>Псевдомасив arguments</li>
                    <li>Перетворення псевдомасиву (args[])</li>
                    <li>Функціональний вираз</li>
                    <li>Колбек-функції</li>
                    <li>Стрілочні функції</li>
                    <li>Чисті функції</li>
                    <li><b>this</b> Правила визначення</li>
                    <li>Методи функцій call, apply і bind</li>
              
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h3>Оголошення функції</h3>
                <p>
                    Починається з ключового слова function, після якого стоїть ім'я - дієслово, 
                        що відповідає на запитання «Що зробити?»            
                </p>
                <code> function multiply() { code }</code>

                <p>
                    Порядок передачі аргументів повинен відповідати порядку оголошених параметрів: значення першого аргументу 
                    буде присвоєно першому параметру, другого аргументу - другому параметру тощо. Якщо параметрів буде більше, 
                    ніж аргументів, то параметрам без значень буде присвоєно undefined
                </p>
                <p>
                    Оператор return без явно вказаного значення повертає спеціальне значення undefined. За відсутності return 
                    в тілі функції, вона все одно поверне undefined
                </p>
                
                <h3>Параметри за замовчуванням</h3>
                <code>function count(countFrom = 0, countTo = 10, step = 1)</code>
                
                <h3>Псевдомасив arguments​</h3>
                <p>
                    Псевдомасив - колекція з властивістю length і можливістю звернутися до елементу за індексом, 
                    але відсутністю більшості методів для роботи з масивом
                </p>
                <pre>
                    function multiply() {
                        let total = 1;
                        for (const argument of arguments) {
                          total *= argument;
                        }
                        return total;
                      }
                      console.log(multiply(1, 2, 3)); //  6
                      console.log(multiply(1, 2, 3, 4)); //  24
                      console.log(multiply(1, 2, 3, 4, 5)); //  120
                </pre>

                <h3>Перетворення псевдомасиву (args[])</h3>
                <p>
                    Зазвичай псевдомасив необхідно перетворити у повноцінний масив Використовуючи метод Array.from()
                </p>
                <pre>
                    function fn() {
                        // Змінна args буде містити повноцінний масив
                        const args = Array.from(arguments);
                    }
                </pre>
                <p>
                    Використовуючи операцію ... (rest), вона дозволяє зібрати будь-яку кількість елементів, 
                    у нашому випадку аргументів, в масив, і зберегти його в змінну.
                </p>
                <pre>
                    function fn(...args) {
                        // Змінна args буде містити повноцінний масив
                    }
                </pre>

                <h3>Функціональний вираз</h3>
                <p>
                    Функціональний вираз (function expression) - звичайне оголошення змінної, значенням якої буде функція. 
                    Альтернативний спосіб оголошення функції.
                </p>
                <pre>
                    const multiply = function (x, y, z) {
                        console.log(`Результат множення дорівнює ${x * y * z}`);
                    };
                </pre>
                <p>
                    Різниця в тому, що функціональний вираз не можна викликати до місця його створення,
                    A оголошення функції можна викликати до місця її створення в коді.
                </p>

                <h4>Область видимості  (пусто)</h4>
                <h4>Стек викликів (пусто)</h4>
                <h4>Переповнення стека викликів (пусто)</h4>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Колбек-функції</h2>
                <p>
                    Функції не відрізняються від чисел, рядків або масивів - це просто спеціальний тип даних (об'єкт вищого порядку), 
                    значення, яке можна зберігати у змінній або передавати у якості аргументу в іншу функцію.
                    Функція зворотного виклику (callback, колбек) - це функція, яка передається іншій функції як аргумент, 
                    а та, в свою чергу, викликає передану функцію.
                </p>
                <pre>
                    // Колбек-функція
                    function greet(name) {
                    console.log(`Ласкаво просимо ${name}.`);
                    }

                    // Функція вищого порядку
                    function registerGuest(name, callback) {
                    console.log(`Реєструємо гостя ${name}.`);
                    callback(name);
                    }

                    registerGuest("Манго", greet);
                </pre>

                <h3>Інлайн колбеки</h3>
                <p>
                    Якщо колбек-функція - маленька, і потрібна тільки для передачі аргументом, її можна оголосити 
                    безпосередньо на момент виклику функції, в яку передаємо колбек. Така функція буде доступна 
                    тільки у якості значення параметра і більше ніде в коді.
                </p>
                <pre>
                    function registerGuest(name, callback) {
                        console.log(`Реєструємо гостя ${name}.`);
                        callback(name);
                      }
                      
                      // Передаємо інлайн функцію greet у якості колбека
                      registerGuest("Манго", function greet(name) {
                        console.log(`Ласкаво просимо ${name}.`);
                      });
                      
                      // Передаємо інлайн функцію notify у якості колбека
                      registerGuest("Полі", function notify(name) {
                        console.log(`Шановний(а) ${name}, ваш номер буде готовий за 30 хвилин.`);
                      });
                </pre>

                <h3>Декілька колбеків</h3>
                <p>
                    Функція може приймати будь-яку кількість колбеків. Наприклад, уявімо, що ми пишемо логіку прийняття 
                    дзвінків для телефону. Програма повинна увімкнути автовідповідач, якщо абонент - недоступний, або 
                    з'єднати дзвінок в іншому випадку. Доступність абонента будемо імітувати генератором випадкового числа, 
                    щоб між різними викликами функції можна було отримати різні результати.
                </p>
                <pre>
                    function processCall(recipient) {
                        // Імітуємо доступність абонента випадковим числом
                        const isRecipientAvailable = Math.random() > 0.5;
                      
                        if (!isRecipientAvailable) {
                          console.log(`Абонент ${recipient} недоступний, залиште повідомлення.`);
                          // Логіка активації автовідповідача
                        } else {
                          console.log(`З'єднуємо з ${recipient}, очікуйте...`);
                          // Логіка прийняття дзвінка
                        }
                      }
                      
                      processCall("Манго");
                </pre>
                <p>
                    Ми могли б написати функцію таким чином, щоб вона повертала якесь значення, і потім за результатом її виконання, 
                    робити перевірки і виконувати потрібний код. Але перевірки не стосуються зовнішнього коду і будуть його засмічувати.
                    Виконаємо рефакторинг функції таким чином, щоб вона приймала два колбеки onAvailable і onNotAvailable, і викликала їх за умовою.
                </p>
                <pre>
                    function processCall(recipient, onAvailable, onNotAvailable) {
                        // Імітуємо доступність абонента випадковим числом
                        const isRecipientAvailable = Math.random() > 0.5;
                      
                        if (!isRecipientAvailable) {
                          onNotAvailable(recipient);
                          return;
                        }
                      
                        onAvailable(recipient);
                      }
                      
                      function takeCall(name) {
                        console.log(`З'єднуємо з ${name}, очікуйте...`);
                        // Логіка прийняття дзвінка
                      }
                      
                      function activateAnsweringMachine(name) {
                        console.log(`Абонент ${name} недоступний, залиште повідомлення.`);
                        // Логіка активації автовідповідача
                      }
                      
                      function leaveHoloMessage(name) {
                        console.log(`Абонент ${name} недоступний, записуємо голограму.`);
                        // Логіка запису голограми
                      }
                      
                      processCall("Манго", takeCall, activateAnsweringMachine);
                      processCall("Полі", takeCall, leaveHoloMessage);
                </pre>
                <p>
                    Колбеки застосовуються для обробки дій користувача на сторінці, на момент обробки 
                    запитів на сервер, виконання заздалегідь невідомих функцій тощо. У цьому і полягає 
                    їх суть - це функції, призначені для відкладеного виконання.
                </p>
                <p>
                    Абстракція - приховування деталей реалізації. Дозволяє думати про задачі на вищому 
                    (абстрактному) рівні. Функції - це хороший спосіб побудови абстракцій.
                </p>
                <pre>
                    function printValue(value) {
                        console.log(value);
                      }
                      
                      function prettyPrint(value) {
                        console.log("Logging value: ", value);
                      }
                      
                      function repeat(n, action) {
                        for (let i = 0; i fgh n; i += 1) {
                          action(i);
                        }
                      }
                      
                      // Передаємо printValue як callback-функцію
                      repeat(3, printValue);
                      // 0
                      // 1
                      // 2
                      
                      // Передаємо prettyPrint як callback-функцію
                      repeat(3, prettyPrint);
                      // Logging value: 0
                      // Logging value: 1
                      // Logging value: 2
                </pre>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Стрілочні функції</h2>
                <p>
                    Стрілочні функції мають скорочений, лаконічніший синтаксис, що зменшує обсяг коду, 
                    особливо коли функція маленька або якщо вона використовується як колбек.
                </p>
                <p>
                    Усі стрілки створюються як функціональний вираз, і якщо функція - не анонімна, 
                    її необхідно присвоювати змінній.
                </p>
                <p>
                    У них відсутній arguments
                </p>
                <pre>
                    const foo = (...rest) => {
                        console.log(rest); // [1,5,7,9,4,5]
                    }
                    foo(1,5,7,9,4,5);
                </pre>
                
                <pre>
                    // Звичайне оголошення функції
                    function classicAdd(a, b, c) {
                        return a + b + c;
                    }

                    // Те саме стрілочною функцією
                    const arrowAdd = (a, b, c) => {
                        return a + b + c;
                    };
                </pre>
                <p>
                    Якщо параметр один, його можна оголошувати без круглих дужок.
                </p>
                <pre>
                    const add = a => {
                        return a + 5;
                    };
                </pre>
                <p>
                    Якщо параметри відсутні, то обов'язково повинні бути порожні круглі дужки.
                </p>
                <pre>
                    const greet = () => {
                        console.log("Привіт!");
                    };

                    супер короткий запис
                    () => {};
                </pre>
                <p>
                    Існує два варіанти: з фігурними дужками і без них.
                    Якщо є фігурні дужки, і функція повинна повертати якесь значення, необхідно 
                    явно поставити return. Це називається явне повернення (explicit return). 
                    Такий синтаксис використовується у разі, якщо в тілі функції потрібно виконати 
                    ще якісь інструкції, крім повернення значення.
                </p>
                <p>
                    Якщо фігурні дужки відсутні, то повертається результат виразу, який стоїть 
                    після =/. Це називається неявне повернення
                </p>
                <pre>
                    const add = (a, b, c) => a + b + c;
                </pre>
                <p>
                    доречний тільки тоді, коли в тілі функції не потрібно виконувати жодних додаткових інструкцій, 
                    крім повернення значення.
                </p>
                <p>
                    У стрілочних функцій немає локальної змінної arguments.Якщо необхідно зібрати всі аргументи в масив, 
                    використовується операція rest
                </p>
                <pre>
                    const add = (...args) => {
                        console.log(args);
                      };
                      
                      add(1, 2, 3); // [1, 2, 3]
                </pre>
                <p>
                    Анонімні стрілочні функції відмінно підходять як колбеки для перебираючих методів масиву завдяки 
                    коротшому синтаксису оголошення
                </p>
                <pre>
                    const numbers = [5, 10, 15, 20, 25];

                // Оголошення функції
                numbers.forEach(function (number, index) {
                    console.log(`Індекс ${index}, значення ${number}`);
                });

                // Анонімна стрілочна функція
                numbers.forEach((number, index) => {
                    console.log(`Індекс ${index}, значення ${number}`);
                });
                </pre>
                <p>
                    Стрілочну колбек-функцію також можна оголошувати окремо і передавати на неї посилання. Це варто робити, 
                    якщо одна функція використовується у декількох місцях програми або якщо вона громіздка.
                </p>
                <pre>
                    const logMessage = (number, index) => {
                        console.log(`Індекс ${index}, значення ${number}`);
                      };
                      
                      numbers.forEach(logMessage);
                </pre>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2></h2>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Чисті функції</h2>
                <p>
                    Функція з побічними ефектами - це функція, яка в процесі виконання може змінювати 
                    або використовувати глобальні змінні, змінювати значення аргументів посилального типу, 
                    виконувати операції введення-виведення тощо.
                </p>
                <p>
                    Чиста функція (pure function) - це функція, результат якої залежить тільки від значень 
                    переданих аргументів. За умови однакових аргументів вона завжди повертає один і той самий 
                    результат і не має побічних ефектів, тобто не змінює значення аргументів
                </p>
                <p>
                    Напишемо реалізацію чистої функції множення елементів масиву, що повертає новий масив, не змінюючи вихідний.
                </p>
                <pre>
                    const pureMultiply = (array, value) => {
                        const newArray = [];
                      
                        array.forEach(element => {
                          newArray.push(element * value);
                        });
                      
                        return newArray;
                      };
                      
                      const numbers = [1, 2, 3, 4, 5];
                      const doubledNumbers = pureMultiply(numbers, 2);
                      
                      // Мутація вихідних даних не відбулася
                      console.log(numbers); // [1, 2, 3, 4, 5]
                      // Функція повернула новий масив зі зміненими даними
                      console.log(doubledNumbers); // [2, 4, 6, 8, 10]
                </pre>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>this Правила визначення</h2>
                <p>
                    У глобальній області видимості, якщо скрипт виконується не в суворому режимі, 
                    this посилається на об'єкт window. В суворому режимі значення this, в глобальній 
                    області видимості, буде undefined.
                </p>
                <pre>
                    function showThis() {
                        console.log("this in showThis: ", this);
                      }
                      
                      // Викликаємо у глобальному контексті
                      showThis(); // this in showThis: Window
                      
                      const user = {
                        username: "Mango",
                      };
                      
                      // Записуємо посилання на функцію у властивість об'єкта
                      // Зверніть увагу, що це не виклик - немає ()
                      user.showContext = showThis;
                      
                      // Викликаємо функцію в контексті об'єкта
                      // this буде вказувати на поточний об'єкт, в контексті
                      // якого здійснюється виклик, а не на глобальний об'єкт.
                      user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}
                </pre>

                <pre>
                    const customer = {
                        firstName: "Jacob",
                        lastName: "Mercer",
                        getFullName() {
                          return `${this.firstName} ${this.lastName}`;
                        },
                      };
                      
                      function makeMessage(callback) {
                        // callback() - це виклик методу getFullName без об'єкта
                        console.log(`Обробляємо заявку від ${callback()}.`);
                      }
                      
                      makeMessage(customer.getFullName); // Буде помилка у виклику функції
                </pre>
                <p>this у стрілочних функціях</p>
                <pre>
                    const showThis = () => {
                        console.log("this in showThis: ", this);
                      };
                      
                      showThis(); // this in showThis: window
                      
                      const user = {
                        username: "Mango",
                      };
                      user.showContext = showThis;
                      
                      user.showContext(); // this in showThis: window
                </pre>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Методи функцій call, apply і bind</h2>
                <p>
                    Трапляються ситуації, коли функцію потрібно викликати в контексті об'єкта, при цьому функція 
                    не є його методом. Для цього у функцій є методи call, apply і bind.
                </p>

                <h3>Метод call()​</h3>
                <pre>
                    foo.call(obj, arg1, arg2, ...)
                </pre>
                <p>
                    Метод call викличе функцію foo таким чином, що в this буде посилання на об'єкт obj, а також передасть аргументи arg1, arg2 тощо.
                </p>
                <pre>
                    function greetGuest(greeting) {
                        console.log(`${greeting}, ${this.username}.`);
                      }
                      
                      const mango = {
                        username: "Манго",
                      };
                      const poly = {
                        username: "Полі",
                      };
                      
                      greetGuest.call(mango, "Ласкаво просимо"); // Ласкаво просимо, Манго.
                      greetGuest.call(poly, "З прибуттям"); // З прибуттям, Полі
                </pre>

                <h3>Метод apply​</h3>
                <pre>
                    foo.apply(obj, [arg1, arg2, ...])
                </pre>
                <p>
                    Метод apply - це аналог методу call за винятком того, що синтаксис передачі аргументів вимагає 
                    не перерахування, а масив, навіть якщо аргумент всього один.
                </p>
                <p>
                    Метод apply викличе функцію foo таким чином, що в this буде посилання на об'єкт obj, а також 
                    передасть елементи масиву як окремі аргументи arg1, arg2 тощо.
                </p>
                <pre>
                    function greetGuest(greeting) {
                        console.log(`${greeting}, ${this.username}.`);
                      }
                      
                      const mango = {
                        username: "Манго",
                      };
                      const poly = {
                        username: "Полі",
                      };
                      
                      greetGuest.apply(mango, ["Ласкаво просимо"]); // Ласкаво просимо, Манго.
                      greetGuest.apply(poly, ["З прибуттям"]); // З прибуттям, Полі.
                </pre>

                <h3>Метод bind()</h3>
                <pre>foo.bind(obj, arg1, arg2, ...)</pre>
                <p>
                    Методи call і apply викликають функцію «на місці», тобто відразу. 
                    Але у разі колбек-функцій, коли необхідно не відразу викликати функцію, 
                    а передати посилання на неї, причому з прив'язаним контекстом, використовується метод bind.
                </p>
                <p>
                    Метод bind створює і повертає копію функції foo з прив'язаним контекстом obj і 
                    аргументами arg1, arg2 тощо. Утворюється копія функції, яку можна передати куди 
                    завгодно і викликати коли завгодно.
                </p>
                <code>
                    function greet(clientName) {
                        return `${clientName}, ласкаво просимо в «${this.service}».`;
                      }
                      
                      const steam = {
                        service: "Steam",
                      };
                      const steamGreeter = greet.bind(steam);
                      steamGreeter("Манго"); // "Манго, ласкаво просимо в «Steam»."
                      
                      const gmail = {
                        service: "Gmail",
                      };
                      const gmailGreeter = greet.bind(gmail);
                      gmailGreeter("Полі"); // "Полі, ласкаво просимо в «Gmail»."
                </code>
                <h4>bind() і методи об'єкта</h4>
                <p>
                    У разі передачі методів об'єкта як колбек-функцій, контекст не зберігається. 
                    Колбек - це посилання на метод, яка присвоюється як значення параметра, що викликається без об'єкта.
                </p>
                <pre>
                    const customer = {
                        firstName: "Jacob",
                        lastName: "Mercer",
                        getFullName() {
                          return `${this.firstName} ${this.lastName}`;
                        },
                      };
                      
                      function makeMessage(callback) {
                        // callback() - це виклик методу getFullName без об'єкта
                        console.log(`Обробляємо заявку від ${callback()}.`);
                      }
                      
                      makeMessage(customer.getFullName); // Виникне помилка на момент виклику функції
                </pre>
                <p>
                    У суворому режимі, значення this в методі getFullName, викликаючи як колбек-функції callback(), 
                    буде undefined. Звертаючись до властивостей firstName і lastName, виникне помилка, оскільки undefined - це не об'єкт.
                    Метод bind використовується для прив'язування контексту, передаючи методи об'єкта як колбек-функції. Передамо колбеком не оригінальний 
                    метод getFullName, а його копію з прив'язаним контекстом об'єкту customer.
                </p>
                <pre>
                    // ❌ Було
                    makeMessage(customer.getFullName); // Виникне помилка на момент виклику функції

                    // ✅ Стало
                    makeMessage(customer.getFullName.bind(customer)); // Обробляємо заявку від Jacob Mercer.
                </pre>

            
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2></h2>
            
            </div>
        </section>



    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
            </address>
        </div>
    </footer>
</body>
</html>