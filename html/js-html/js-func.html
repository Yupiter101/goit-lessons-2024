<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
    <!-- Goodle font -->
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Wet+Paint&display=swap" rel="stylesheet"> -->
    
    <!-- modern-normalize -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />

    <!-- css -->
    <link rel="stylesheet" href="../../css/styles-basic.css">
</head>

<body>
    <header>
        <div>
            <a  class="fixed-back" href="../../index.html">Back to main page</a>
            <nav>
            </nav>
        </div>
    </header>

    <main>
        <section class="section-title">
            <div class="container">
                <h1>JS Функції</h1>
            </div>
        </section>

        <section class="section-menu">
            <div class="container">
                <h2>Зміст</h2>
                <ol>
                    <li>Оголошення функції</li>
                    <li>Параметри за замовчуванням</li>
                    <li>Псевдомасив arguments</li>
                    <li>Перетворення псевдомасиву (args[])</li>
                    <li>Функціональний вираз</li>
                    <li>Колбек-функції</li>
                    <li>Стрілочні функції</li>
                    <li>Чисті функції</li>
              
                </ol>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h3>Оголошення функції</h3>
                <p>
                    Починається з ключового слова function, після якого стоїть ім'я - дієслово, 
                        що відповідає на запитання «Що зробити?»            
                </p>
                <code> function multiply() { code }</code>

                <p>
                    Порядок передачі аргументів повинен відповідати порядку оголошених параметрів: значення першого аргументу 
                    буде присвоєно першому параметру, другого аргументу - другому параметру тощо. Якщо параметрів буде більше, 
                    ніж аргументів, то параметрам без значень буде присвоєно undefined
                </p>
                <p>
                    Оператор return без явно вказаного значення повертає спеціальне значення undefined. За відсутності return 
                    в тілі функції, вона все одно поверне undefined
                </p>
                
                <h3>Параметри за замовчуванням</h3>
                <code>function count(countFrom = 0, countTo = 10, step = 1)</code>
                
                <h3>Псевдомасив arguments​</h3>
                <p>
                    Псевдомасив - колекція з властивістю length і можливістю звернутися до елементу за індексом, 
                    але відсутністю більшості методів для роботи з масивом
                </p>
                <pre>
                    function multiply() {
                        let total = 1;
                        for (const argument of arguments) {
                          total *= argument;
                        }
                        return total;
                      }
                      console.log(multiply(1, 2, 3)); //  6
                      console.log(multiply(1, 2, 3, 4)); //  24
                      console.log(multiply(1, 2, 3, 4, 5)); //  120
                </pre>

                <h3>Перетворення псевдомасиву (args[])</h3>
                <p>
                    Зазвичай псевдомасив необхідно перетворити у повноцінний масив Використовуючи метод Array.from()
                </p>
                <pre>
                    function fn() {
                        // Змінна args буде містити повноцінний масив
                        const args = Array.from(arguments);
                    }
                </pre>
                <p>
                    Використовуючи операцію ... (rest), вона дозволяє зібрати будь-яку кількість елементів, 
                    у нашому випадку аргументів, в масив, і зберегти його в змінну.
                </p>
                <pre>
                    function fn(...args) {
                        // Змінна args буде містити повноцінний масив
                    }
                </pre>

                <h3>Функціональний вираз</h3>
                <p>
                    Функціональний вираз (function expression) - звичайне оголошення змінної, значенням якої буде функція. 
                    Альтернативний спосіб оголошення функції.
                </p>
                <pre>
                    const multiply = function (x, y, z) {
                        console.log(`Результат множення дорівнює ${x * y * z}`);
                    };
                </pre>
                <p>
                    Різниця в тому, що функціональний вираз не можна викликати до місця його створення,
                    A оголошення функції можна викликати до місця її створення в коді.
                </p>

                <h4>Область видимості  (пусто)</h4>
                <h4>Стек викликів (пусто)</h4>
                <h4>Переповнення стека викликів (пусто)</h4>
                
            </div>
        </section>


        <section class="section-about">
            <div class="container">
                <h2>Колбек-функції</h2>
                <p>
                    Функції не відрізняються від чисел, рядків або масивів - це просто спеціальний тип даних (об'єкт вищого порядку), 
                    значення, яке можна зберігати у змінній або передавати у якості аргументу в іншу функцію.
                    Функція зворотного виклику (callback, колбек) - це функція, яка передається іншій функції як аргумент, 
                    а та, в свою чергу, викликає передану функцію.
                </p>
                <pre>
                    // Колбек-функція
                    function greet(name) {
                    console.log(`Ласкаво просимо ${name}.`);
                    }

                    // Функція вищого порядку
                    function registerGuest(name, callback) {
                    console.log(`Реєструємо гостя ${name}.`);
                    callback(name);
                    }

                    registerGuest("Манго", greet);
                </pre>

                <h3>Інлайн колбеки</h3>
                <p>
                    Якщо колбек-функція - маленька, і потрібна тільки для передачі аргументом, її можна оголосити 
                    безпосередньо на момент виклику функції, в яку передаємо колбек. Така функція буде доступна 
                    тільки у якості значення параметра і більше ніде в коді.
                </p>
                <pre>
                    function registerGuest(name, callback) {
                        console.log(`Реєструємо гостя ${name}.`);
                        callback(name);
                      }
                      
                      // Передаємо інлайн функцію greet у якості колбека
                      registerGuest("Манго", function greet(name) {
                        console.log(`Ласкаво просимо ${name}.`);
                      });
                      
                      // Передаємо інлайн функцію notify у якості колбека
                      registerGuest("Полі", function notify(name) {
                        console.log(`Шановний(а) ${name}, ваш номер буде готовий за 30 хвилин.`);
                      });
                </pre>

                <h3>Декілька колбеків</h3>
                <p>
                    Функція може приймати будь-яку кількість колбеків. Наприклад, уявімо, що ми пишемо логіку прийняття 
                    дзвінків для телефону. Програма повинна увімкнути автовідповідач, якщо абонент - недоступний, або 
                    з'єднати дзвінок в іншому випадку. Доступність абонента будемо імітувати генератором випадкового числа, 
                    щоб між різними викликами функції можна було отримати різні результати.
                </p>
                <pre>
                    function processCall(recipient) {
                        // Імітуємо доступність абонента випадковим числом
                        const isRecipientAvailable = Math.random() > 0.5;
                      
                        if (!isRecipientAvailable) {
                          console.log(`Абонент ${recipient} недоступний, залиште повідомлення.`);
                          // Логіка активації автовідповідача
                        } else {
                          console.log(`З'єднуємо з ${recipient}, очікуйте...`);
                          // Логіка прийняття дзвінка
                        }
                      }
                      
                      processCall("Манго");
                </pre>
                <p>
                    Ми могли б написати функцію таким чином, щоб вона повертала якесь значення, і потім за результатом її виконання, 
                    робити перевірки і виконувати потрібний код. Але перевірки не стосуються зовнішнього коду і будуть його засмічувати.
                    Виконаємо рефакторинг функції таким чином, щоб вона приймала два колбеки onAvailable і onNotAvailable, і викликала їх за умовою.
                </p>
                <pre>
                    function processCall(recipient, onAvailable, onNotAvailable) {
                        // Імітуємо доступність абонента випадковим числом
                        const isRecipientAvailable = Math.random() > 0.5;
                      
                        if (!isRecipientAvailable) {
                          onNotAvailable(recipient);
                          return;
                        }
                      
                        onAvailable(recipient);
                      }
                      
                      function takeCall(name) {
                        console.log(`З'єднуємо з ${name}, очікуйте...`);
                        // Логіка прийняття дзвінка
                      }
                      
                      function activateAnsweringMachine(name) {
                        console.log(`Абонент ${name} недоступний, залиште повідомлення.`);
                        // Логіка активації автовідповідача
                      }
                      
                      function leaveHoloMessage(name) {
                        console.log(`Абонент ${name} недоступний, записуємо голограму.`);
                        // Логіка запису голограми
                      }
                      
                      processCall("Манго", takeCall, activateAnsweringMachine);
                      processCall("Полі", takeCall, leaveHoloMessage);
                </pre>
                <p>
                    Колбеки застосовуються для обробки дій користувача на сторінці, на момент обробки 
                    запитів на сервер, виконання заздалегідь невідомих функцій тощо. У цьому і полягає 
                    їх суть - це функції, призначені для відкладеного виконання.
                </p>
                <p>
                    Абстракція - приховування деталей реалізації. Дозволяє думати про задачі на вищому 
                    (абстрактному) рівні. Функції - це хороший спосіб побудови абстракцій.
                </p>
                <pre>
                    function printValue(value) {
                        console.log(value);
                      }
                      
                      function prettyPrint(value) {
                        console.log("Logging value: ", value);
                      }
                      
                      function repeat(n, action) {
                        for (let i = 0; i fgh n; i += 1) {
                          action(i);
                        }
                      }
                      
                      // Передаємо printValue як callback-функцію
                      repeat(3, printValue);
                      // 0
                      // 1
                      // 2
                      
                      // Передаємо prettyPrint як callback-функцію
                      repeat(3, prettyPrint);
                      // Logging value: 0
                      // Logging value: 1
                      // Logging value: 2
                </pre>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Стрілочні функції</h2>
                <p>
                    Стрілочні функції мають скорочений, лаконічніший синтаксис, що зменшує обсяг коду, 
                    особливо коли функція маленька або якщо вона використовується як колбек.
                </p>
                <p>
                    Усі стрілки створюються як функціональний вираз, і якщо функція - не анонімна, 
                    її необхідно присвоювати змінній.
                </p>
                
                <pre>
                    // Звичайне оголошення функції
                    function classicAdd(a, b, c) {
                        return a + b + c;
                    }

                    // Те саме стрілочною функцією
                    const arrowAdd = (a, b, c) => {
                        return a + b + c;
                    };
                </pre>
                <p>
                    Якщо параметр один, його можна оголошувати без круглих дужок.
                </p>
                <pre>
                    const add = a => {
                        return a + 5;
                    };
                </pre>
                <p>
                    Якщо параметри відсутні, то обов'язково повинні бути порожні круглі дужки.
                </p>
                <pre>
                    const greet = () => {
                        console.log("Привіт!");
                      };
                </pre>
                <p>
                    Існує два варіанти: з фігурними дужками і без них.
                    Якщо є фігурні дужки, і функція повинна повертати якесь значення, необхідно 
                    явно поставити return. Це називається явне повернення (explicit return). 
                    Такий синтаксис використовується у разі, якщо в тілі функції потрібно виконати 
                    ще якісь інструкції, крім повернення значення.
                </p>
                <p>
                    Якщо фігурні дужки відсутні, то повертається результат виразу, який стоїть 
                    після =/. Це називається неявне повернення
                </p>
                <pre>
                    const add = (a, b, c) => a + b + c;
                </pre>
                <p>
                    доречний тільки тоді, коли в тілі функції не потрібно виконувати жодних додаткових інструкцій, 
                    крім повернення значення.
                </p>
                <p>
                    У стрілочних функцій немає локальної змінної arguments.Якщо необхідно зібрати всі аргументи в масив, 
                    використовується операція rest
                </p>
                <pre>
                    const add = (...args) => {
                        console.log(args);
                      };
                      
                      add(1, 2, 3); // [1, 2, 3]
                </pre>
                <p>
                    Анонімні стрілочні функції відмінно підходять як колбеки для перебираючих методів масиву завдяки 
                    коротшому синтаксису оголошення
                </p>
                <pre>
                    const numbers = [5, 10, 15, 20, 25];

                // Оголошення функції
                numbers.forEach(function (number, index) {
                    console.log(`Індекс ${index}, значення ${number}`);
                });

                // Анонімна стрілочна функція
                numbers.forEach((number, index) => {
                    console.log(`Індекс ${index}, значення ${number}`);
                });
                </pre>
                <p>
                    Стрілочну колбек-функцію також можна оголошувати окремо і передавати на неї посилання. Це варто робити, 
                    якщо одна функція використовується у декількох місцях програми або якщо вона громіздка.
                </p>
                <pre>
                    const logMessage = (number, index) => {
                        console.log(`Індекс ${index}, значення ${number}`);
                      };
                      
                      numbers.forEach(logMessage);
                </pre>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2></h2>
            </div>
        </section>

        <section class="section-about">
            <div class="container">
                <h2>Чисті функції</h2>
            </div>
        </section>


    </main>
    <footer class="page-footer">
        <div class="container">
            <h3>footer</h3>
            <address>
            </address>
        </div>
    </footer>
</body>
</html>